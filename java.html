<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"/>
    <link rel="stylesheet" href="css/index.css"/>
    <title>Java</title>
</head>
<body>
    <nav class="mb-5">
        <mi-navegacion></mi-navegacion>
    </nav>
    <main>
        <mi-lista class="overflow-scroll">
<!-- 1.INTRODUCCI√ìN A JAVA           -->
            <tema-item>
              <titulo>
                <strong>1.Introducci√≥n a JAVA</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Introducci√≥n a Java</h2>
                 <h4>1. Introducci√≥n a Java</h4>
                 <p>Java es un lenguaje de programaci√≥n orientado a objetos, desarrollado por Sun Microsystems y
                    lanzado en 1995. Fue dise√±ado con la idea de escribir c√≥digo que se pudiera ejecutar en 
                    cualquier dispositivo sin necesidad de modificaci√≥n (gracias al lema: "Write Once, Run Anywhere").
                 </p>
                 <h4>üï∞Ô∏è 2. Historia de Java</h4>
                 <p>
                  ¬∑&nbsp;1991: James Gosling y su equipo en Sun Microsystems crean un proyecto llamado Oak, 
                   que luego se convertir√≠a en Java.<br>
                  ¬∑&nbsp;1995: Se lanza oficialmente Java como una plataforma para aplicaciones web y de escritorio.<br>
                  ¬∑&nbsp;2009: Oracle Corporation adquiere Sun Microsystems y con ello Java.<br>
                  ¬∑&nbsp;Actualidad: Java sigue siendo uno de los lenguajes m√°s utilizados en el mundo, 
                         especialmente en sistemas empresariales, m√≥viles (Android) y aplicaciones de servidor.
                 </p>
                 <h4>‚≠ê 3. Caracter√≠sticas de Java</h4>
                 <p>
                  ¬∑&nbsp;Multiplataforma: Gracias a la JVM (Java Virtual Machine), puedes ejecutar el mismo programa 
                    en diferentes sistemas operativos.<br>
                  ¬∑&nbsp;Orientado a objetos: Todo en Java es un objeto (salvo los tipos primitivos).<br>
                  ¬∑&nbsp;Sintaxis similar a C/C++: Facilita el aprendizaje si ya conoces estos lenguajes.<br>
                  ¬∑&nbsp;Recogida de basura autom√°tica: Java libera la memoria autom√°ticamente.<br>
                  ¬∑&nbsp;Seguro: Manejo de errores, control de acceso, y verificaci√≥n de bytecode.<br>
                  ¬∑&nbsp;Multihilo (multithreading): Permite ejecutar m√∫ltiples tareas al mismo tiempo.
                 </p>
                 <h4>üõ†Ô∏è 4. Instalaci√≥n de JDK y configuraci√≥n del entorno</h4>
                 <p>a) Descargar el JDK<br>
                   1.Ve a la p√°gina oficial de Oracle:  <a href="https://www.oracle.com/java/technologies/downloads/">JDK JAVA</a><br>
                   2.Descarga el JDK (Java Development Kit) adecuado para tu sistema operativo.<br>
                   3.Instala el JDK.  
                 </p>
                  <p>b) Configurar variables de entorno (Windows)<br>
                   1.Abre el Panel de control > Sistema > Configuraci√≥n avanzada del sistema.<br>
                   2.Haz clic en Variables de entorno.<br>
                   3.Agrega o edita la variable JAVA_HOME con la ruta donde instalaste el JDK (por ejemplo: C:\Program Files\Java\jdk-17).<br>
                   4.Agrega %JAVA_HOME%\bin a la variable Path.<br>
                 </p>
                 <p>
                  c) Verificar la instalaci√≥n.<br>
                  Abre la terminal o consola y ejecuta:
                 </p>
                 <code><pre>
                  java -version
                  javac -version
                 </pre></code> 
                 <p>Deber√≠as ver la versi√≥n de Java instalada.</p>
                 <h4>üíª 5. Primer programa en Java: Hola Mundo</h4>
                 <p>a) Crear el archivo<br>
                  Crea un archivo llamado HolaMundo.java con el siguiente contenido:
                 </p>
                 <code><pre>
                  public class HolaMundo {
                    public static void main(String[] args) {
                        System.out.println("¬°Hola, mundo!");
                    }
                  }               
                 </pre></code> 
                 <p>b) Compilar el archivo><br>
                  Abre la terminal en la carpeta donde est√° el archivo y escribe:
                 </p>
                 <code><pre>
                  javac HolaMundo.java
                 </pre></code>
                 <p>c) Ejecutar el programa</p>
                 <code><pre>
                  java HolaMundo 
                 </pre></code> 
                 <p>Salida:</p>
                 <code><pre>
                  ¬°Hola, mundo!
                 </pre></code>  
               </div>
            </tema-item>
<!-- 2.B√°sico-Sintaxis b√°sica           -->
            <tema-item>
              <titulo>
                <strong>2.B√°sico-Sintaxis b√°sica</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Sintaxis B√°sica</h2>
                 <h4>1. Sintaxis b√°sica de Java</h4>
                 <p>Java es un lenguaje fuertemente tipado y orientado a objetos. Cada 
                     l√≠nea de c√≥digo debe terminar en ;, y el c√≥digo se organiza en clases.
                 </p>
                 <h4>2.Estructura de una clase en Java</h4>
                 <code><pre>
                 public class Persona {
                 // Atributos o propiedades
                 String nombre;
                  int edad;

                // Constructor
                public Persona(String nombre, int edad) {
                     this.nombre = nombre;
                     this.edad = edad;
                }

                // M√©todo
                public void saludar() {
                System.out.println("Hola, mi nombre es " + nombre);
                 }
                }
                <br>
                <p>
                ¬∑&nbsp;public class Persona: definici√≥n de la clase.<br>
                ¬∑&nbsp;Atributos: nombre y edad.<br>
                ¬∑&nbsp;Constructor: se llama igual que la clase.<br>
                ¬∑&nbsp;M√©todo: funci√≥n dentro de la clase (saludar).  
                </p>
                </pre></code>
                <h4>3.M√©todos y funciones</h4>
                <p>En Java toda funci√≥n es un m√©todo, ya que debe pertenecer a una clase.<br>
                Sintaxis de un m√©todo:
                </p> 
                <code><pre>
                  [modificador de acceso] [tipo de retorno] nombreMetodo(par√°metros) {
                   // c√≥digo
                  }
                </pre></code> 
                <p>Ejemplo:</p>
                <code><pre>
                  public int sumar(int a, int b) {
                  return a + b;
                }
                </pre></code>
                <p>
                  ¬∑&nbsp;public: modificador de acceso.<br>
                  ¬∑&nbsp;int: tipo de retorno.<br>
                  ¬∑&nbsp;sumar: nombre del m√©todo.<br>
                  ¬∑&nbsp;(int a, int b): par√°metros.<br>
                  ¬∑&nbsp;return: valor que devuelve.
                </p>
                <h4>4.M√©todo main</h4>
                <p>Punto de entrada de un programa Java. Obligatorio para que se pueda ejecutar.</p>
                <code><pre>
                  public class Principal {
                  public static void main(String[] args) {
                  Persona p = new Persona("Rodolfo", 30);
                  p.saludar();
                    }
                  }
                  <br>
                  <p>
                   ¬∑&nbsp;public static void main(String[] args): m√©todo principal.<br>
                   ¬∑&nbsp; String[] args: argumentos de l√≠nea de comandos (opcional de usar).
                  </p>
                </pre></code>
                <h4> 5. Comentarios</h4> 
                <code><pre>
                // Comentario de una l√≠nea
                /*
                Comentario
                de varias
                l√≠neas
                */

                /                **
                 * Comentario de documentaci√≥n (JavaDoc)
                 * para describir clases o m√©todos.
                 */
                </pre></code>
                <h4>6. Convenciones de nombres en Java</h4>
                <table border="1">
                  <thead>
                    <tr>
                     <th>Tipo</th>
                      <th>Convenci√≥n</th>
                      <th>Ejemplo</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Clases</td>
                      <td>PascalCase (inicial may√∫sc.)</td>
                      <td>MiClase, Persona</td>
                    </tr>
                    <tr>
                      <td>M√©todos/funciones</td>
                      <td>camelCase</td>
                      <td>calcularSuma()</td>
                    </tr>
                    <tr>
                      <td>Variables</td>
                      <td>camelCase</td>
                      <td>miEdad, nombreCompleto</td>
                    </tr>
                    <tr>
                      <td>Constantes</td>
                      <td>MAY√öSCULAS_CON_GUIONES</td>
                      <td>VALOR_MAXIMO</td>
                    </tr>
                    <tr>
                      <td>Paquetes</td>
                      <td>min√∫sculas y puntos</td>
                      <td>com.ejemplo.miapp</td>
                   </tr>
                  </tbody>
                </table>
           
               </div>
            </tema-item>
<!-- 3.B√°sico-Tipo de datos y variables           -->
            <tema-item>
              <titulo>
                <strong>3.B√°sico-Tipo de datos y variables.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Tipo de datos y variables.</h2>
                 <h4>Tipos de datos en Java</h4>
                 <p>S√≥lo texto simple.</p>
                 <p>Java divide los tipos de datos en dos grandes categor√≠as:<br>
                 ¬∑&nbsp; a) Tipos primitivos (almacenan directamente valores)
                 </p>
                 <code><pre>
                 <table border="1">
                   <thead>
                     <tr>
                       <th>Tipo</th>
                       <th>Tama√±o (bits)</th>
                       <th>Valor Ejemplo</th>
                       <th>Descripci√≥n</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td>byte</td>
                        <td>8</td>
                        <td>byte edad = 25;</td>
                        <td>Entero peque√±o (-128 a 127)</td>
                      </tr>
                      <tr>
                        <td>short</td>
                        <td>16</td>
                        <td>short s = 1000;</td>
                        <td>Entero corto</td>
                      </tr>
                      <tr>
                        <td>int</td>
                        <td>32</td>
                        <td>int x = 100000;</td>
                        <td>Entero com√∫n</td>
                      </tr>
                      <tr>
                        <td>long</td>
                        <td>64</td>
                        <td>long l = 123456L;</td>
                        <td>Entero grande (a√±ade L)</td>
                     </tr>
                      <tr>
                        <td>float</td>
                        <td>32</td>
                        <td>float f = 5.5f;</td>
                       <td>Decimal (usa f)</td>
                      </tr>
                      <tr>
                        <td>double</td>
                        <td>64</td>
                        <td>double d = 3.14;</td>
                        <td>Decimal m√°s preciso</td>
                      </tr>
                      <tr>
                        <td>char</td>
                       <td>16</td>
                        <td>char c = 'A';</td>
                        <td>Car√°cter Unicode</td>
                      </tr>
                      <tr>
                        <td>boolean</td>
                        <td>1 (l√≥gico)</td>
                        <td>boolean b = true;</td>
                        <td>true o false</td>
                      </tr>
                    </tbody>
                 </table>
                 </pre></code>
                 <p>üîπ b) Tipos por referencia (objetos)<br>
                 String, Array, Clases, Interfaces
                 </p> 
                 <code><pre>
                  String nombre = "Rodolfo";
                  int[] numeros = {1, 2, 3};
                 </pre></code> 
                 <p>2. Variables.<br>
                 Declaraci√≥n:
                 </p>
                 <code><pre>
                  int edad = 30;
                  String nombre = "Ana";
                  <br>
                  <p>
                    ¬∑&nbsp;Se especifica el tipo, el nombre y, opcionalmente, un valor.<br>
                    ¬∑&nbsp;Se pueden declarar m√∫ltiples variables del mismo tipo:
                  </p>
                 </pre></code>
                 <code><pre>
                  int a = 1, b = 2, c = 3;
                 </pre></code> 
                 <p>3. Constantes (final)<br>
                 ¬∑&nbsp;Las constantes no pueden cambiar su valor una vez asignadas.
                 </p>
                 <code><pre>
                  final double PI = 3.1416;
                  ¬∑&nbsp;Convenci√≥n: usar may√∫sculas con guiones bajos.<br>
                  ¬∑&nbsp;Se pueden usar con private, static, etc.
                 </pre></code> 
                 <code><pre>
                  private static final int VALOR_MAXIMO = 100;
                 </pre></code>
                 <h4> 4. Modificadores comunes</h4>
                  <table border="1">
                    <thead>
                      <tr>
                        <th>Modificador</th>
                        <th>Significado</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>public</code></td>
                        <td>Accesible desde cualquier clase</td>
                      </tr>
                      <tr>
                        <td><code>private</code></td>
                        <td>Accesible solo dentro de la clase</td>
                      </tr>
                                        <tr>
                        <td><code>protected</code></td>
                        <td>Accesible dentro del paquete o subclases</td>
                      </tr>
                      <tr>
                        <td><code>static</code></td>
                        <td>Pertenece a la clase y no a instancias</td>
                      </tr>
                      <tr>
                        <td><code>final</code></td>
                        <td>No puede cambiar su valor o ser sobreescrito</td>
                      </tr>
                    </tbody>
                  </table>
                  <h4>5. Conversi√≥n y casting</h4>
                  <p> a) Conversi√≥n impl√≠cita (widening)<br>
                  De un tipo menor a uno mayor autom√°ticamente:
                  </p>
                  <code><pre>
                    int x = 10;
                    double y = x; // int a double (autom√°tico)
                  </pre></code> 
                  <p>üîπ b) Casting expl√≠cito (narrowing)<br>
                  De un tipo mayor a uno menor (puede perder informaci√≥n):
                  </p>
                  <code><pre>
                    double a = 9.8;
                    int b = (int) a; // b ser√° 9
                  </pre></code> 
                  <p> c) Conversiones con objetos</p>
                  <code><pre>
                    String numero = "123";
                    int n = Integer.parseInt(numero); // String a int
                  </pre></code>
                  <p>üìå Ejemplo resumen en c√≥digo:</p>
                  <code><pre>
                  public class EjemploTipos {
                    public static void main(String[] args) {
                        final double PI = 3.1416; // constante

                        int edad = 30;
                        double peso = 70.5;
                        boolean esMayor = true;
                        char inicial = 'R';

                        S                 tring nombre = "Rodolfo";
                        int numero = Integer.parseInt("100");

                        double resultado = edad + peso; // conversi√≥n impl√≠cita
                        int truncado = (int) peso; // casting expl√≠cito

                        System.out.println("Hola " + nombre + ", edad: " + edad);
                    }
                  }
                  </pre></code>  
              </div>
             </tema-item>
<!-- 4.B√°sico-Operadores           -->
            <tema-item>
              <titulo>
                <strong>4.B√°sico-Operadores.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Operadores.</h2>
                 <p>En Java existen distintos tipos de operadores que permiten realizar operaciones
                    con variables y valores. A continuaci√≥n, te explico cada tipo con ejemplos:
                  </p>
                 <h4>1. Operadores Aritm√©ticos</h4>
                 <p>Se usan para realizar operaciones matem√°ticas.</p>
                 <table border="1">
                   <thead>
                     <tr>
                       <th>Operador</th>
                       <th>Significado</th>
                       <th>Ejemplo (<code>a = 10</code>, <code>b = 3</code>)</th>
                       <th>Resultado</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td><code>+</code></td>
                       <td>Suma</td>
                       <td><code>a + b</code></td>
                       <td>13</td>
                     </tr>
                     <tr>
                       <td><code>-</code></td>
                       <td>Resta</td>
                       <td><code>a - b</code></td>
                       <td>7</td>
                     </tr>
                     <tr>
                       <td><code>*</code></td>
                       <td>Multiplicaci√≥n</td>
                       <td><code>a * b</code></td>
                       <td>30</td>
                     </tr>
                     <tr>
                       <td><code>/</code></td>
                       <td>Divisi√≥n</td>
                       <td><code>a / b</code></td>
                       <td>3</td>
                     </tr>
                     <tr>
                       <td><code>%</code></td>
                       <td>M√≥dulo (resto)</td>
                       <td><code>a % b</code></td>
                       <td>1</td>
                     </tr>
                   </tbody>
                 </table>
                 <h4> 2. Operadores Relacionales (de comparaci√≥n)</h4>
                 <p>Comparan dos valores y devuelven true o false.</p>
                 <table border="1">
                   <thead>
                     <tr>
                       <th>Operador</th>
                       <th>Significado</th>
                       <th>Ejemplo (<code>a = 10</code>, <code>b = 3</code>)</th>
                       <th>Resultado</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td><code>==</code></td>
                       <td>Igual a</td>
                       <td><code>a == b</code></td>
                       <td>false</td>
                     </tr>
                     <tr>
                       <td><code>!=</code></td>
                      <td>Distinto de</td>
                       <td><code>a != b</code></td>
                       <td>true</td>
                     </tr>
                     <tr>
                       <td><code>></code></td>
                       <td>Mayor que</td>
                       <td><code>a > b</code></td>
                       <td>true</td>
                     </tr>
                     <tr>
                       <td><code><</code></td>
                       <td>Menor que</td>
                       <td><code>a < b</code></td>
                       <td>false</td>
                     </tr>
                     <tr>
                       <td><code>>=</code></td>
                       <td>Mayor o igual que</td>
                       <td><code>a >= b</code></td>
                       <td>true</td>
                     </tr>
                     <tr>
                       <td><code><=</code></td>
                       <td>Menor o igual que</td>
                       <td><code>a <= b</code></td>
                       <td>false</td>
                     </tr>
                    </tbody>
                 </table>
                 <h4>3. Operadores L√≥gicos</h4>
                 <p>Se usan con expresiones booleanas (true o false).</p>
                 <table border="1">
                    <thead>
                      <tr>
                        <th>Operador</th>
                        <th>Nombre</th>
                        <th>Descripci√≥n</th>
                        <th>Ejemplo (<code>a = 10</code>, <code>b = 3</code>)</th>
                        <th>Resultado</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>&&</code></td>
                        <td>AND l√≥gico</td>
                        <td>Verdadero si <strong>ambas condiciones</strong> son <code>true</code></td>
                        <td><code>(a > 5 && b < 5)</code></td>
                        <td>true</td>
                      </tr>
                      <tr>
                        <td><code>||</code></td>
                        <td>OR l√≥gico</td>
                        <td>Verdadero si <strong>al menos una</strong> condici√≥n es <code>true</code></td>
                        <td><code>(a < 5 || b < 5)</code></td>
                        <td>true</td>
                      </tr>
                      <tr>
                        <td><code>!</code></td>
                        <td>NOT l√≥gico</td>
                        <td>Invierte el valor l√≥gico</td>
                        <td><code>!(a > b)</code></td>
                        <td>false</td>
                      </tr>
                    </tbody>
                 </table>
                 <h4>4. Operadores de Asignaci√≥n</h4>
                 <p>Asignan valores a las variables.</p>
                 <table border="1">
                    <thead>
                      <tr>
                        <th>Operador</th>
                        <th>Ejemplo</th>
                        <th>Equivalente a</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>=</code></td>
                        <td><code>x = 5</code></td>
                        <td>Asigna 5 a <code>x</code></td>
                      </tr>
                      <tr>
                        <td><code>+=</code></td>
                        <td><code>x += 2</code></td>
                        <td><code>x = x + 2</code></td>
                      </tr>
                      <tr>
                        <td><code>-=</code></td>
                        <td><code>x -= 2</code></td>
                        <td><code>x = x - 2</code></td>
                      </tr>
                      <tr>
                        <td><code>*=</code></td>
                        <td><code>x *= 3</code></td>
                        <td><code>x = x * 3</code></td>
                      </tr>
                      <tr>
                        <td><code>/=</code></t>
                        <td><code>x /= 2</code></td>
                        <td><code>x = x / 2</code></td>
                      </tr>
                      <tr>
                        <td><code>%=</code></td>
                        <td><code>x %= 2</code></td>
                        <td><code>x = x % 2</code></td>
                      </tr>
                    </tbody>
                  </table>
                  <h4>5. Operador Ternario</h4>
                  <p>Es una forma corta de escribir una condici√≥n if-else.<br>
                  Sintaxis:
                  </p>
                 <code><pre>
                  resultado = (condici√≥n) ? valor_si_verdadero : valor_si_falso;
                 </pre></code> 
                 <code><pre>
                  int edad = 18;
                  String mensaje = (edad >= 18) ? "Mayor de edad" : "Menor de edad";
                  System.out.println(mensaje); // Imprime "Mayor de edad"
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
               </div>
             </tema-item>
<!-- 5.B√°sico-Control de flujo           -->
            <tema-item>
              <titulo>
                <strong>5.B√°sico-Control de flujo.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Control de flujo.</h2>
                 <p> En Java, el control de flujo permite tomar decisiones y repetir
                     acciones seg√∫n ciertas condiciones. Se divide principalmente en 
                     condicionales y bucles. A continuaci√≥n te explico cada uno con ejemplos:
                  </p>
               <h4>üîπ CONDICIONALES</h4>
               <p>1. if <br>
               Ejecuta un bloque de c√≥digo si la condici√≥n es verdadera.
               </p>
               <code><pre>
                int edad = 20;

                if (edad >= 18) {
                System.out.println("Eres mayor de edad.");
                }
               </pre></code> 
               <p>2. if - else<br>
               Permite ejecutar una alternativa si la condici√≥n es falsa.
               </p>
               <code><pre>
                if (edad >= 18) {
                System.out.println("Mayor de edad");
                } else {
                System.out.println("Menor de edad");
                }
               </pre></code> 
               <p>3. if - else if - else<br>
               Permite evaluar m√∫ltiples condiciones.
               </p>
               <code><pre>
                int nota = 7;

                if (nota >= 6) {
                System.out.println("Excelente");
                } else if (nota >= 4) {
                System.out.println("Aprobado");
                } else {
                System.out.println("Reprobado");
                }
               </pre></code>
               <p>4. switch <br>
              Selecciona una de muchas opciones posibles seg√∫n el valor de una variable.
               </p>
               <code><pre>
                int dia = 3;

                switch (dia) {
                    case 1:
                        System.out.println("Lunes");
                        break;
                    case 2:
                        System.out.println("Martes");
                        break;
                    case 3:
                        System.out.println("Mi√©rcoles");
                        break;
                    default:
                        System.out.println("D√≠a inv√°lido");
                }
                <br>
                <p> Usa break para salir del bloque switch y evitar que contin√∫e evaluando otros case.</p>
               </pre></code>
               <h4>üîπ BUCLES</h4> 
               <p>1. for<br>
               Repite un bloque un n√∫mero determinado de veces. 
               </p>
               <code><pre>
                for (int i = 1; i <= 5; i++) {
                System.out.println("Repetici√≥n " + i);
                }
               </pre></code>
               <p>2. while<br>
                Repite mientras la condici√≥n sea verdadera.
               </p>
               <code><pre>
                int i = 1;

                while (i <= 5) {
                System.out.println("Contador: " + i);
                i++;
                }
               </pre></code> 
               <p>3. do-while<br>
               Similar a while, pero se ejecuta al menos una vez.
               </p>
               <code><pre>
                int i = 1;

                do {
                System.out.println("Contador: " + i);
                i++;
                } while (i <= 5);
               </pre></code> 
               <p>¬øCu√°ndo usar cu√°l?</p>
                 <table border="1">
                    <thead>
                      <tr>
                        <th>Estructura</th>
                        <th>Se usa cuando...</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>if</code></td>
                        <td>Se toma una decisi√≥n simple.</td>
                      </tr>
                      <tr>
                        <td><code>if-else</code></td>
                        <td>Hay dos caminos posibles.</td>
                      </tr>
                      <tr>
                        <td><code>else if</code></td>
                         <td>Se deben evaluar m√∫ltiples condiciones.</td>
                      </tr>
                      <tr>
                        <td><code>switch</code></td>
                        <td>Se elige entre varias opciones fijas (enteros, strings, etc.).</td>
                      </tr>
                      <tr>
                        <td><code>for</code></td>
                        <td>Sabes cu√°ntas veces repetir√°s.</td>
                      </tr>
                      <tr>
                        <td><code>while</code></td>
                        <td>Repetici√≥n depende de una condici√≥n.</td>
                      </tr>
                      <tr>
                        <td><code>do-while</code></td>
                        <td>Al menos una ejecuci√≥n garantizada.</td>
                      </tr>
                    </tbody>
                 </table>
                 <h4>üîπ break</h4>
                 <p>Se utiliza para salir inmediatamente de un bucle o switch.<br>
                 Ejemplo en un for:
                 </p>
                 <code><pre>
                  for (int i = 1; i <= 10; i++) {
                  if (i == 5) {
                  break; // Se detiene cuando i es 5
                  }
                  System.out.println("i = " + i);
                  }
                 </pre></code> 
                 <p>Salida:</p>
                 <code><pre>
                  i = 1
                  i = 2
                  i = 3
                  i = 4
                 </pre></code>
                 <p>Tambi√©n se usa en switch:</p>
                 <code><pre>
                  switch (dia) {
                  case 1:
                  System.out.println("Lunes");
                  break; // evita que siga evaluando otros casos
                  case 2:
                  System.out.println("Martes");
                  break;
                  }
                 </pre></code>
                 <h4>üîπ continue</h4> 
                 <p>Se usa para saltar al siguiente ciclo de iteraci√≥n, ignorando el resto del c√≥digo en esa vuelta.<br>
                  Ejemplo en un for:
                 </p>
                 <code><pre>
                  for (int i = 1; i <= 5; i++) {
                  if (i == 3) {
                  continue; // salta esta iteraci√≥n cuando i es 3
                  }
                  System.out.println("i = " + i);
                  }
                 </pre></code> 
                 <p>Salida:</p>
                 <code><pre>
                  i = 1
                  i = 2
                  i = 4
                  i = 5
                 </pre></code> 
                 <h4>Resumen.</h4>
                 <table border="1">
                   <thead>
                                      <tr>
                       <th>Palabra clave</th>
                      <th>¬øQu√© hace?</th>
                       <th>¬øD√≥nde se usa?</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td><code>break</code></td>
                       <td>Sale inmediatamente del bucle o <code>switch</code></td>
                       <td><code>for</code>, <code>while</code>, <code>do-while</code>, <code>switch</code></td>
                     </tr>
                     <tr>
                       <td><code>continue</code></td>
                       <td>Salta el resto del ciclo actual y pasa al siguiente</td>
                       <td><code>for</code>, <code>while</code>, <code>do-while</code></td>
                     </tr>
                   </tbody>
                 </table>
 
                 </div>
            </tema-item>
<!-- 6.B√°sico-Arreglos y cuerdas           -->
            <tema-item>
              <titulo>
                <strong>6.B√°sico-Arreglos y cuerdas.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Arreglos y cuerdas.</h2>
                 <p>En Java, arreglos y cadenas de texto (Strings) son estructuras clave para
                     almacenar y manipular datos.
                 </p>
                 <h4>üîπ ARREGLOS (Arrays)</h4>
                 <p></p>
                 <code><pre>
                 </pre></code> 
                 <p>1. ¬øQu√© es un arreglo?<br>
                  Un arreglo es una estructura que almacena m√∫ltiples valores del mismo tipo en una sola variable.
                 </p>
                 <p>2. Declaraci√≥n y uso de un arreglo</p>
                 <code><pre>
                  int[] numeros = new int[5];           // Arreglo de 5 enteros
                  numeros[0] = 10;                      // Asignar valor al primer elemento
                  System.out.println(numeros[0]);      // Mostrar el primer valor
                 </pre></code> 
                 <p>Tambi√©n se puede inicializar directamente:</p>
                 <code><pre>
                  int[] pares = {2, 4, 6, 8};
                  System.out.println(pares[2]);  // Imprime 6
                 </pre></code>
                 <p>3. Recorrer un arreglo con for</p>
                 <code><pre>
                  for (int i = 0; i < pares.length; i++) {
                  System.out.println(pares[i]);
                  }
                 </pre></code> 
                 <p>4. Arreglos multidimensionales<br>
                 Son arreglos de arreglos (matrices):
                 </p>
                 <code><pre>
                  int[][] matriz = {
                  {1, 2, 3},
                  {4, 5, 6}
                  };

                  System.out.println(matriz[1][2]); // Imprime 6
                 </pre></code> 
                 <p>Para recorrerlos:</p>
                 <code><pre>
                  for (int i = 0; i < matriz.length; i++) {
                  for (int j = 0; j < matriz[i].length; j++) {
                  System.out.print(matriz[i][j] + " ");
                  }
                  System.out.println();
                  }
                 </pre></code>
                 <h4>üîπ CADENAS DE TEXTO (Strings)</h4>
                 <p>1. ¬øQu√© es un String?<br>
                 Una cadena de texto (String) es un objeto que representa texto.
                 </p>
                 <code><pre>
                  String saludo = "Hola mundo";
                  System.out.println(saludo);
                 </pre></code> 
                 <p>2. M√©todos √∫tiles de String</p>
                 <table border="1">
                   <thead>
                     <tr>
                        <th>M√©todo</th>
                        <th>Descripci√≥n</th>
                        <th>Ejemplo</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>length()</code></td>
                        <td>Largo de la cadena</td>
                        <td><code>saludo.length()</code> ‚Üí <code>10</code></td>
                      </tr>
                      <tr>
                        <td><code>charAt(i)</code></td>
                        <td>Devuelve car√°cter en posici√≥n <code>i</code></td>
                        <td><code>saludo.charAt(0)</code> ‚Üí <code>'H'</code></td>
                      </tr>
                      <tr>
                        <td><code>toUpperCase()</code></td>
                        <td>Convierte a may√∫sculas</td>
                        <td><code>saludo.toUpperCase()</code> ‚Üí <code>"HOLA MUNDO"</code></td>
                      </tr>
                      <tr>
                        <td><code>toLowerCase()</code></td>
                        <td>Convierte a min√∫sculas</td>
                        <td><code>saludo.toLowerCase()</code> ‚Üí <code>"hola mundo"</code></td>
                      </tr>
                      <tr>
                        <td><code>substring(i, j)</code></td>
                       <td>Extrae subcadena desde <code>i</code> hasta <code>j</code></td>
                        <td><code>saludo.substring(0, 4)</code> ‚Üí <code>"Hola"</code></td>
                      </tr>
                      <tr>
                        <td><code>equals(str)</code></td>
                        <td>Compara si dos strings son iguales</td>
                        <td><code>"Hola".equals("hola")</code> ‚Üí <code>false</code></td>
                     </tr>
                      <tr>
                        <td><code>contains(str)</code></td>
                        <td>Verifica si contiene subcadena</td>
                        <td><code>saludo.contains("mun")</code> ‚Üí <code>true</code></td>
                      </tr>
                      <tr>
                        <td><code>replace(a, b)</code></td>
                        <td>Reemplaza texto</td>
                        <td><code>saludo.replace("Hola", "Chao")</code></td>
                      </tr>
                    </tbody>
                 </table>
                 <h4>3. Concatenaci√≥n de Strings</h4>
                 <code><pre>
                  String nombre = "Rodolfo";
                  String mensaje = "Hola " + nombre; // Usando +
                  System.out.println(mensaje);

                  String completo = String.format("Hola %s", nombre); // Usando format
                 </pre></code> 
                 <h4>4. Convertir entre String y tipos primitivos</h4>
                 <code><pre>
                  int numero = Integer.parseInt("123");    // String a int
                  String texto = String.valueOf(456);      // int a String
                 </pre></code>   
                 </div>
            </tema-item>
<!-- 7.B√°sico-M√©todos y alcance           -->
            <tema-item>
              <titulo>
                <strong>7.B√°sico-M√©todos y alcance.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>M√©todos y alcance.</h2>
                 <h4>üîπ ¬øQu√© es un m√©todo en Java?</h4>
                 <p>Un m√©todo es un bloque de c√≥digo que se puede reutilizar. 
                    Sirve para agrupar instrucciones que realizan una tarea espec√≠fica.
                 </p>
                 <p>Sintaxis b√°sica:</p>
                 <code><pre>
                  public tipoDeRetorno nombreMetodo(tipo parametro) {
                  // cuerpo del m√©todo
                  return valor; // si no es void
                  }
                 </pre></code>
                 <h4>üî∏ Par√°metros y retorno (return)</h4> 
                 <p>Los m√©todos pueden recibir par√°metros (valores de entrada) y devolver un valor con return.<br>
                  Ejemplo:
                 </p>
                 <code><pre>
                  public int sumar(int a, int b) {
                  return a + b;
                  }
                 </pre></code> 
                 <p>Llamada:</p>
                 <code><pre>
                  int resultado = sumar(2, 3); // resultado = 5
                  <br>
                  <p>
                    ¬∑&nbsp;int ‚Üí tipo de retorno<br>
                    ¬∑&nbsp;a, b ‚Üí par√°metros<br>
                    ¬∑&nbsp;return a + b; ‚Üí valor que retorna el m√©todo
                  </p>
                 </pre></code>
                 <h4>üî∏ M√©todo void (sin retorno)</h4>
                 <code><pre>
                  public void saludar(String nombre) {
                  System.out.println("Hola, " + nombre);
                  }
                 </pre></code>
                 <h4>üîπ Sobrecarga de m√©todos (Overloading)</h4> 
                 <p>Es cuando un mismo m√©todo tiene el mismo nombre pero diferentes par√°metros (tipo o n√∫mero).</p>
                 <code><pre>
                  public int sumar(int a, int b) {
                  return a + b;
                  }

                  public double sumar(double a, double b) {
                  return a + b;
                  }
                  <br>
                  <p>Java elige cu√°l ejecutar seg√∫n los argumentos.</p>
                 </pre></code>
                 <h4>üîπ Variables locales y globales</h4> 
                 <table border="1">
                    <thead>
                      <tr>
                        <th>Tipo</th>
                        <th>¬øD√≥nde se declara?</th>
                        <th>¬øAlcance?</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Local</td>
                        <td>Dentro de un m√©todo</td>
                      </tr>
                      <tr>
                        <td>Global / de instancia</td>
                        <td>Dentro de la clase (fuera de m√©todos)</td>
                        <td>Accesible desde todos los m√©todos de la clase</td>
                                        </tr>
                    </tbody>
                  </table>
                 <p>Ejemplo:</p>
                 <code><pre>
                  public class Persona {
                  // Variable global o de instancia
                  String nombre = "Rodolfo";

                  public void mostrarNombre() {
                  // Variable local
                  int edad = 30;
                  System.out.println(nombre + ", edad: " + edad);
                  }
                }
                 </pre></code>
                 <h4>Resumen de tipos de m√©todos</h4>
                 <table border="1">
                   <thead>
                     <tr>
                       <th>Tipo</th>
                       <th>Tiene retorno</th>
                       <th>Tiene par√°metros</th>
                       <th>Ejemplo</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td>M√©todo simple</td>
                       <td>No</td>
                       <td>No</td>
                       <td><code>public void mostrar()</code></td>
                     </tr>
                     <tr>
                       <td>Con par√°metros</td>
                       <td>No</td>
                       <td>S√≠</td>
                       <td><code>public void saludar(String nombre)</code></td>
                     </tr>
                     <tr>
                       <td>Con retorno</td>
                       <td>S√≠</td>
                       <td>S√≠</td>
                       <td><code>public int sumar(int a, int b)</code></td>
                     </tr>
                   </tbody>
                  </table>
  
               </div>
            </tema-item>
<!-- 8.Intermedio-POO           -->
            <tema-item>
              <titulo>
                <strong>8.Intermedio-POO.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Programaci√≥n Orientada a Objetos.</h2>
                 <p>Te explico cada uno de estos conceptos de Programaci√≥n Orientada 
                    a Objetos (POO) en Java, con ejemplos simples para que se entienda mejor:
                 </p>
                 <h4> 1. Clases</h4>
                 <p>Una clase es una plantilla o molde que define c√≥mo ser√°n los objetos. Contiene atributos
                    (variables) y m√©todos (funciones).
                 </p>
                 <code><pre>
                  public class Persona {
                    String nombre;
                    int edad;

                    void saludar() {
                    System.out.println("Hola, mi nombre es " + nombre);
                      }
                  }
                 </pre></code>
                 <h4>üîπ 2. Objetos</h4> 
                 <p>Un objeto es una instancia de una clase. Se crea usando new.</p>
                 <code><pre>
                  Persona p1 = new Persona();
                  p1.nombre = "Juan";
                  p1.edad = 30;
                  p1.saludar(); // Imprime: Hola, mi nombre es Juan
                 </pre></code>
                 <h4> 3. Encapsulamiento</h4> 
                 <p>Es ocultar los datos internos de una clase y acceder a ellos solo 
                    mediante m√©todos p√∫blicos (getters y setters).
                 </p>
                 <code><pre>
                  public class CuentaBancaria {
                    private double saldo; // Atributo privado

                    public double getSaldo() {
                      return saldo;
                    }

                  public void depositar(double cantidad) {
                    if (cantidad > 0) {
                    saldo += cantidad;
                    }
                  }
                }
                 </pre></code>
                 <p>Uso:</p>
                 <code><pre>
                  CuentaBancaria cuenta = new CuentaBancaria();
                  cuenta.depositar(500);
                  System.out.println(cuenta.getSaldo()); // Imprime: 500.0
                 </pre></code>
                 <h4>4. Constructores</h4> 
                 <p>Un constructor es un m√©todo especial que se llama al crear un objeto. Se usa para inicializar atributos.</p>
                 <code><pre>
                  public class Persona {
                      String nombre;
                      int edad;

                      // Constructor
                      public Persona(String nombre, int edad) {
                      this.nombre = nombre;
                      this.edad = edad;
                    }
                  }
                 </pre></code> 
                 <p>Uso:</p>
                 <code><pre>
                  Persona p2 = new Persona("Ana", 25);
                 </pre></code>
                 <h4>üîπ 5. this</h4>
                 <p>La palabra clave this se refiere al objeto actual. Se usa para distinguir 
                    entre atributos y par√°metros con el mismo nombre.
                 </p>
                 <code><pre>
                  public class Persona {
                    String nombre;

                  public Persona(String nombre) {
                    this.nombre = nombre; // this.nombre se refiere al atributo
                    }
                  }
                 </pre></code>
                 <h4>üîπ 6. super</h4> 
                 <p>La palabra clave super se usa para:<br>
                  ¬∑&nbsp;Llamar al constructor de la clase padre.<br>
                  ¬∑&nbsp;Acceder a m√©todos o atributos heredados.
                 </p>
                 <code><pre>
                  public class Animal {
                   String tipo;

                   public Animal(String tipo) {
                   this.tipo = tipo;
                   }

                   void hacerSonido() {
                   System.out.println("Sonido gen√©rico");
                  }
                }

                  public class Perro extends Animal {
                  public Perro() {
                  super("Canino"); // Llama al constructor de Animal
                  }

                  @Override
                  void hacerSonido() {
                  super.hacerSonido(); // Llama al m√©todo de la clase padre
                  System.out.println("Guau!");
                  }
                }
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code>   
               </div>
            </tema-item>
<!-- 9.Intermedio-Herencia y Polimorfismo.           -->
            <tema-item>
              <titulo>
                <strong>9.Intermedio-Herencia y Polimorfismo.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Herencia y Polimorfismo.</h2>
                 <h4>üî∑ 1. Herencia</h4>
                 <p>La herencia permite que una clase herede atributos y m√©todos de otra. 
                    Promueve la reutilizaci√≥n de c√≥digo.<br>
                    ¬∑&nbsp;üß± Ejemplo:
                 </p>
                 <code><pre>
                  public class Animal {
                       void hacerSonido() {
                            System.out.println("Sonido gen√©rico");
                        }
                      }

                  public class Perro extends Animal {
                         void moverCola() {
                             System.out.println("El perro mueve la cola");
                        }
                      }
                 </pre></code> 
                 <p>Uso:</p>
                 <code><pre>
                  Perro miPerro = new Perro();
                  miPerro.hacerSonido(); // Heredado de Animal
                  miPerro.moverCola();   // Propio de Perro
                 </pre></code>
                 <h4>üî∑ 2. Clases Derivadas (Subclases)</h4> 
                 <p>Una clase derivada o subclase es la que hereda de otra. Se declara con extends.</p>
                 <code><pre>
                  public class Gato extends Animal {
                      void maullar() {
                          System.out.println("Miau");
                      }
                    }
                 </pre></code>
                 <h4>üî∑ 3. Polimorfismo</h4>
                 <p>
                  El polimorfismo permite que un mismo m√©todo tenga diferentes comportamientos 
                  dependiendo del objeto que lo invoque.
                 </p>
                 <h5>üî∏ Tipos de polimorfismo en Java:</h5>
                 <p>a. Polimorfismo en tiempo de compilaci√≥n (Overload)<br>
                  Overload es cuando hay varios m√©todos con el mismo nombre pero diferentes par√°metros.
                 </p>
                 <code><pre>
                  public class Calculadora {
                      int sumar(int a, int b) {
                          return a + b;
                      }

                      double sumar(double a, double b) {
                          return a + b;
                      }
                    }
                 </pre></code> 
                 <p> b. Polimorfismo en tiempo de ejecuci√≥n (Override)<br>
                  Override es cuando una subclase redefine un m√©todo de su superclase.
                 </p>
                 <code><pre>
                  public class Animal {
                     void hacerSonido() {
                         System.out.println("Sonido gen√©rico");
                      }
                  }

                  public class Gato extends Animal {
                      @Override
                      void hacerSonido() {
                          System.out.println("Miau");
                       }
                  }

                 </pre></code> 
                 <p>Uso:</p>
                 <code><pre>
                  Animal miAnimal = new Gato(); // Polimorfismo
                  miAnimal.hacerSonido(); // Imprime: Miau
                  <br>
                  <p>
                    Aunque miAnimal es de tipo Animal, el m√©todo sobrescrito de Gato se ejecuta.
                  </p>
                 </pre></code> 
                 <h4>üî∑ 4. Resumen Visual</h4>
                 <table border="1" cellpadding="8" cellspacing="0">
                    <thead>
                      <tr>
                        <th>Concepto</th>
                        <th>¬øQu√© hace?</th>
                        <th>Palabra clave</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Herencia</td>
                        <td>Reutiliza c√≥digo de una superclase</td>
                        <td><code>extends</code></td>
                      </tr>
                      <tr>
                                          <td>Override</td>
                        <td>Redefine un m√©todo heredado</td>
                        <td><code>@Override</code></td>
                      </tr>
                      <tr>
                        <td>Overload</td>
                        <td>Crea m√©todos con mismo nombre, distintos par√°metros</td>
                        <td>(ninguna)</td>
                      </tr>
                      <tr>
                        <td>Polimorfismo</td>
                        <td>Cambia comportamiento seg√∫n el tipo del objeto</td>
                        <td>din√°mico</td>
                      </tr>
                    </tbody>
                  </table>
 
               </div>
            </tema-item>
<!-- 10.Intermedio-Interfaces y clases abstractas.           -->
            <tema-item>
              <titulo>
                <strong>10.Intermedio-Interfaces y clases abstractas.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Interfaces y clases abstractas.</h2>
                 <p>S√≥lo texto simple.</p>
                 <h4>üî∑ 1. Clases Abstractas</h4>
                 <p>Una clase abstracta es una clase que no se puede instanciar 
                    y puede tener m√©todos abstractos (sin cuerpo) y m√©todos normales
                    (con implementaci√≥n). Se usa como base para otras clases.
                 </p>
                 <p>Ejemplo</p>
                 <code><pre>
                  public abstract class Animal {
                      // M√©todo abstracto (sin cuerpo)
                      public abstract void hacerSonido();

                      // M√©todo concreto (con implementaci√≥n)
                      public void dormir() {
                          System.out.println("El animal est√° durmiendo");
                        }
                    }
                 </pre></code> 
                 <p>Subclase concreta que la implementa:</p>
                 <code><pre>
                  public class Perro extends Animal {
                  @Override
                  public void hacerSonido() {
                     System.out.println("Guau");
                     }
                  }
                 </pre></code>
                 <h4>üî∑ 2. Interfaces</h4> 
                 <p>Una interface es como un contrato: define m√©todos p√∫blicos 
                  abstractos que una clase debe implementar. Las clases usan 
                  implements para aplicar una interfaz.
                 </p>
                 <p>
                   Ejemplo:
                 </p>
                 <code><pre>
                  public interface Vehiculo {
                      void arrancar();
                      void detener();
                  }
                 </pre></code>
                 <p>Clase que implementa la interfaz:</p>
                 <code><pre>
                  public class Auto implements Vehiculo {
                       @Override
                       public void arrancar() {
                           System.out.println("El auto arranca");
                       }

                       @Override
                       public void detener() {
                           System.out.println("El auto se detiene");
                        }
                    }
                 </pre></code>
                 <h4>üî∑ 3. Diferencias: Clase Abstracta vs Interfaz</h4>
                 <table border="1" cellpadding="8" cellspacing="0">
                    <thead>
                      <tr>
                        <th>Caracter√≠stica</th>
                        <th>Clase Abstracta</th>
                        <th>Interfaz</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Herencia</td>
                        <td><code>extends</code></td>
                        <td><code>implements</code></td>
                      </tr>
                      <tr>
                        <td>M√©todos abstractos</td>
                        <td>Puede tener</td>
                        <td>Todos abstractos por defecto (hasta Java 7)</td>
                      </tr>
                      <tr>
                        <td>M√©todos con c√≥digo</td>
                        <td>Puede tener</td>
                        <td>Desde Java 8, s√≠ (default/static)</td>
                      </tr>
                      <tr>
                        <td>M√∫ltiples implementaciones</td>
                        <td>No (solo una clase padre)</td>
                        <td>S√≠ (una clase puede implementar varias)</td>
                      </tr>
                      <tr>
                        <td>Constructores</td>
                        <td>S√≠</td>
                        <td>No</td>
                      </tr>
                    </tbody>
                  </table>
                  <h4>üî∑ 4. M√©todos Abstractos</h4>
                  <p>Son m√©todos sin cuerpo. Las clases hijas deben implementarlos.</p>
                  <code><pre>
                    abstract class Figura {
                         public abstract double calcularArea();
                    }
                  </pre></code>
                  <h4>üî∑ 5. Interfaces Funcionales (Desde Java 8)</h4>
                  <p>Una interfaz funcional es una interfaz que tiene solo un m√©todo abstracto. 
                      Son usadas con expresiones lambda.
                  </p>
                  <p>Ejemplo:</p>
                  <code><pre>
                    @FunctionalInterface
                    public interface Operacion {
                        int aplicar(int a, int b);
                    }
                  </pre></code> 
                  <p>Uso con lambda:</p>
                  <code><pre>
                    public class Main {
                       public static void main(String[] args) {
                           Operacion suma = (a, b) -> a + b;
                           System.out.println(suma.aplicar(3, 5)); // Imprime: 8
                         }
                    }
                  </pre></code>
                  <h4>üîö Resumen</h4> 
                  <table border="1" cellpadding="8" cellspacing="0">
                     <thead>
                       <tr>
                         <th>Concepto</th>
                         <th>¬øQu√© es?</th>
                         <th>Palabra clave</th>
                       </tr>
                     </thead>
                     <tbody>
                       <tr>
                         <td>Clase abstracta</td>
                         <td>Clase incompleta que sirve como base</td>
                         <td><code>abstract class</code></td>
                       </tr>
                       <tr>
                         <td>M√©todo abstracto</td>
                         <td>M√©todo sin cuerpo que se debe implementar</td>
                         <td><code>abstract</code></td>
                       </tr>
                       <tr>
                         <td>Interfaz</td>
                         <td>Contrato con m√©todos abstractos por implementar</td>
                         <td><code>interface</code></td>
                       </tr>
                       <tr>
                         <td>Implementaci√≥n</td>
                                            <td>Clase que aplica una interfaz</td>
                         <td><code>implements</code></td>
                       </tr>
                       <tr>
                         <td>Interfaz funcional</td>
                         <td>Interfaz con un solo m√©todo abstracto (para lambdas)</td>
                         <td><code>@FunctionalInterface</code></td>
                       </tr>
                     </tbody>
                   </table>
  
               </div>
            </tema-item> 
<!-- 11.Intermedio-Modificadores de acceso.           -->
            <tema-item>
              <titulo>
                <strong>11.Intermedio-Modificadores de acceso.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Modificadores de acceso.</h2>
                 <p>Vamos paso a paso explicando modificadores de acceso, 
                    modificadores de clase, y manejo de excepciones en Java, 
                    con ejemplos claros.
                 </p>
                 <h4>üî∑ 1. Modificadores de Acceso</h4>
                 <p>Los modificadores de acceso controlan la visibilidad de clases, m√©todos y atributos.</p>
                 <table border="1" cellpadding="8" cellspacing="0">
                    <thead>
                      <tr>
                        <th>Modificador</th>
                        <th>Accesible desde‚Ä¶</th>
                        <th>Palabra clave</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>public</code></td>
                        <td>Cualquier clase de cualquier paquete</td>
                        <td><code>public</code></td>
                      </tr>
                      <tr>
                        <td><code>private</code></td>
                        <td>Solo dentro de la misma clase</td>
                        <td><code>private</code></td>
                      </tr>
                      <tr>
                        <td><code>protected</code></td>
                        <td>Misma clase, subclases y mismo paquete</td>
                        <td><code>protected</code></td>
                      </tr>
                      <tr>
                        <td>(por defecto)</td>
                        <td>Solo dentro del mismo paquete</td>
                        <td><em>(sin palabra)</em></td>
                      </tr>
                   </tbody>
                 </table>
                 <h4>üî∑ 2. Modificadores static y final</h4>
                 <p>static: pertenece a la clase y no al objeto.</p>
                 <code><pre>
                  public class Util {
                     public static int sumar(int a, int b) {
                     return a + b;
                    }
                  }

                  // Se usa as√≠:
                  int resultado = Util.sumar(5, 3);
                 </pre></code> 
                 <p> final: impide que algo se modifique.<br>
                  ¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;final en variables: no puede cambiar su valor.<br>
                  ¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;final en m√©todos: no puede ser sobrescrito.<br>
                  ¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;¬∑&nbsp;final en clases: no puede ser heredada.
                 </p>
                 <code><pre>
                  final int PI = 3.1416; // constante

                  final class MiClase {
                  // Esta clase no puede tener subclases
                  }
                 </pre></code>
                 <h4>üî∑ 3. Manejo de Excepciones en Java</h4> 
                 <p>Se usa para manejar errores en tiempo de ejecuci√≥n sin que el programa se detenga bruscamente.<br>
                  try-catch:
                 </p>
                 <code><pre>
                  try {
                      int resultado = 10 / 0; // Error: divisi√≥n por cero
                  } catch (ArithmeticException e) {
                      System.out.println("Error: " + e.getMessage());
                  }
                 </pre></code>
                 <p>finally: se ejecuta siempre, haya error o no.</p>
                 <code><pre>
                  try {
                      // C√≥digo riesgoso
                  } catch (Exception e) {
                     // Manejo
                  } finally {
                     System.out.println("Siempre se ejecuta");
                  }
                 </pre></code>
                 <h4>4. throw y throws</h4> 
                 <p>throw: lanza una excepci√≥n espec√≠fica manualmente.</p>
                 <code><pre>
                  if (edad < 0) {
                  throw new IllegalArgumentException("Edad no puede ser negativa");
                  }
                 </pre></code> 
                 <p>throws: declara que un m√©todo puede lanzar una excepci√≥n.</p>
                 <code><pre>
                  public void leerArchivo(String nombre) throws IOException {
                 // Puede lanzar IOException
                }
                 </pre></code>
                 <h4>üî∑ 5. Excepciones Personalizadas </h4>
                 <p>Puedes crear tus propias excepciones heredando de Exception o RuntimeException.<br>
                  Ejemplo:
                 </p>
                 <code><pre>
                  public class EdadInvalidaException extends Exception {
                     public EdadInvalidaException(String mensaje) {
                     super(mensaje);
                     }
                  }
                 </pre></code> 
                 <p>Uso:</p>
                 <code><pre>
                  public void setEdad(int edad) throws EdadInvalidaException {
                     if (edad < 0) {
                        throw new EdadInvalidaException("Edad no v√°lida");
                     }
                  }
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
               </div>
            </tema-item>
<!-- 12.Intermedio-Colecciones.           -->
            <tema-item>
              <titulo>
                <strong>12.Intermedio-Colecciones.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Colecciones.</h2>
                 <h4>üîπ 1. Listas (List)</h4>
                 <p>Las listas mantienen el orden de inserci√≥n y permiten elementos duplicados.</p>
                 <p>ArrayList<br>
                    ¬∑&nbsp;Implementaci√≥n basada en arreglos din√°micos.<br>
                    ¬∑&nbsp;Acceso r√°pido por √≠ndice, pero inserciones/eliminaciones son lentas (excepto al final).
                 </p>
                 <code><pre>
                  import java.util.ArrayList;

                  ArrayList<String> lista = new ArrayList<>();
                  lista.add("Juan");
                  lista.add("Ana");
                  System.out.println(lista.get(0)); // Juan
                 </pre></code> 
                 <p>LinkedList<br>
                    ¬∑&nbsp;Basada en lista doblemente enlazada.<br>
                    ¬∑&nbsp;Inserciones y eliminaciones m√°s r√°pidas en el medio, pero acceso m√°s lento por √≠ndice.
                 </p>
                 <code><pre>
                  import java.util.LinkedList;

                  LinkedList<String> lista = new LinkedList<>();
                  lista.add("Carlos");
                  lista.addFirst("Luis");
                  System.out.println(lista); // [Luis, Carlos]
                 </pre></code>
                 <h4>üîπ 2. Conjuntos (Set)</h4> 
                 <p>No permiten elementos duplicados.</p>
                 <p>HashSet<br>
                   ¬∑&nbsp;No mantiene orden. <br>
                   ¬∑&nbsp;Basado en una tabla hash.<br>
                   ¬∑&nbsp;Muy r√°pido para b√∫squeda e inserci√≥n.
                 </p>
                 <code><pre>
                  import java.util.HashSet;

                  HashSet<String> conjunto = new HashSet<>();
                  conjunto.add("Rojo");
                  conjunto.add("Verde");
                  conjunto.add("Rojo"); // No se repite
                  System.out.println(conjunto); // [Rojo, Verde]
                 </pre></code>
                 <p>TreeSet<br>
                  ¬∑&nbsp;Mantiene los elementos en orden natural (alfab√©tico o num√©rico).<br>
                  ¬∑&nbsp;M√°s lento que HashSet.
                 </p>
                 <code><pre>
                  import java.util.TreeSet;

                  TreeSet<Integer> numeros = new TreeSet<>();
                  numeros.add(5);
                  numeros.add(2);
                  numeros.add(9);
                  System.out.println(numeros); // [2, 5, 9]
                 </pre></code>
                 <h4>üîπ 3. Mapas (Map)</h4> 
                 <p>Almacenan pares clave-valor. Las claves deben ser √∫nicas.</p>
                 <p>HashMap<br>
                   ¬∑&nbsp;No garantiza orden.<br>
                   ¬∑&nbsp;Muy eficiente.
                 </p>
                 <code><pre>
                  import java.util.HashMap;

                  HashMap<String, Integer> edades = new HashMap<>();
                  edades.put("Ana", 30);
                  edades.put("Luis", 25);
                  System.out.println(edades.get("Ana")); // 30
                 </pre></code> 
                 <p>TreeMap<br>
                   ¬∑&nbsp;Ordena las claves en orden natural.
                 </p>
                 <code><pre>
                  import java.util.TreeMap;
 
                  TreeMap<String, String> paises = new TreeMap<>();
                  paises.put("MX", "M√©xico");
                  paises.put("US", "Estados Unidos");
                  System.out.println(paises); // {MX=M√©xico, US=Estados Unidos}
                 </pre></code>
                 <h4>üîπ 4. Iteradores</h4> 
                 <p>Se usan para recorrer colecciones con m√°s control que un bucle for.</p>
                 <code><pre>
                  import java.util.Iterator;
                  import java.util.ArrayList;

                  ArrayList<String> nombres = new ArrayList<>();
                  nombres.add("Ana");
                  nombres.add("Luis");

                  Iterator<String> it = nombres.iterator();
                  while (it.hasNext()) {
                       System.out.println(it.next());
                  }
                 </pre></code>
                 <h4>üîπ 5. Bucle for-each</h4> 
                 <p>Forma m√°s simple de recorrer colecciones.</p>
                 <code><pre>
                  for (String nombre : nombres) {
                      System.out.println(nombre);
                  }
                 </pre></code> 
                 <h4> Resumen </h4>
                 <table border="1" cellpadding="8" cellspacing="0">
                    <thead>
                      <tr>
                        <th>Tipo</th>
                        <th>Clase</th>
                        <th>Orden</th>
                        <th>Duplicados</th>
                        <th>Clave/Valor</th>
                        <th>Ejemplo uso</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Lista</td>
                        <td>ArrayList</td>
                        <td>S√≠</td>
                        <td>S√≠</td>
                        <td>No</td>
                        <td>Acceso r√°pido</td>
                      </tr>
                      <tr>
                        <td>Lista</td>
                        <td>LinkedList</td>
                        <td>S√≠</td>
                        <td>S√≠</td>
                        <td>No</td>
                        <td>Inserci√≥n r√°pida</td>
                      </tr>
                      <tr>
                        <td>Conjunto</td>
                        <td>HashSet</td>
                        <td>No</td>
                        <td>No</td>
                        <td>No</td>
                        <td>Detecci√≥n duplicados</td>
                      </tr>
                      <tr>
                        <td>Conjunto</td>
                        <td>TreeSet</td>
                        <td>S√≠</td>
                        <td>No</td>
                        <td>No</td>
                        <td>Orden natural</td>
                      </tr>
                      <tr>
                        <td>Mapa</td>
                        <td>HashMap</td>
                        <td>No</td>
                        <td>-</td>
                        <td>S√≠</td>
                        <td>Acceso por clave</td>
                      </tr>
                      <tr>
                        <td>Mapa</td>
                        <td>TreeMap</td>
                        <td>S√≠</td>
                        <td>-</td>
                        <td>S√≠</td>
                        <td>Orden por clave</td>
                      </tr>
                    </tbody>
                  </table>
               </div>
            </tema-item>
<!-- 13.Intermedio-Cadenas y Fechas.           -->
            <tema-item>
              <titulo>
                <strong>13.Intermedio-Cadenas y Fechas.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Cadenas y Fechas.</h2>
                 <h4>üîπ 1. Cadenas en Java (String y StringBuilder)</h4>
                 <p>String<br>
                    ¬∑&nbsp;Es inmutable: no se puede modificar una vez creada.<br>
                    ¬∑&nbsp;Operaciones comunes:
                 </p>
                 <code><pre>
                  String texto = "Hola";
                  texto = texto + " mundo"; // Se crea un nuevo objeto
                  System.out.println(texto); // Hola mundo

                  // Otros m√©todos √∫tiles
                  texto.length();
                  texto.toUpperCase();
                  texto.contains("mundo");
                 </pre></code> 
                 <p>StringBuilder<br>
                   ¬∑&nbsp;Clase mutable, ideal para concatenar muchas cadenas sin crear nuevos objetos.<br>
                   ¬∑&nbsp;Mucho m√°s eficiente que String en ciclos o grandes vol√∫menes.
                 </p>
                 <code><pre>
                  StringBuilder sb = new StringBuilder("Hola");
                  sb.append(" mundo");
                  System.out.println(sb.toString()); // Hola mundo
                 </pre></code> 
                 <h4>üîπ2. Fechas antiguas (Date y Calendar)</h4>
                 <p>Date (java.util.Date) <br>
                  ¬∑&nbsp;Clase antigua, reemplazada en gran parte por java.time.<br>
                  ¬∑&nbsp;Sirve para representar fechas y horas, pero su API es limitada.
                 </p>
                 <code><pre>
                  import java.util.Date;

                  Date ahora = new Date();
                  System.out.println(ahora); // Muestra fecha y hora actuales
                 </pre></code>
                 <p>Calendar<br>
                 ¬∑&nbsp;Permite manipular componentes individuales de la fecha.
                 </p>
                 <code><pre>
                  import java.util.Calendar;

                  Calendar cal = Calendar.getInstance();
                  cal.set(2025, Calendar.MAY, 9);
                  System.out.println(cal.getTime()); // Fri May 09 00:00:00 ...
                 </pre></code>
                 <h4>üîπ 3. Nueva API de fechas (java.time) ‚Äì desde Java 8</h4> 
                 <p>Mucho m√°s moderna, segura y legible.</p>
                 <p>LocalDate<br>
                  ¬∑&nbsp;Representa una fecha sin hora (solo a√±o, mes, d√≠a).
                 </p>
                 <code><pre>
                  import java.time.LocalDate;

                  LocalDate hoy = LocalDate.now();
                  LocalDate nacimiento = LocalDate.of(2000, 5, 15);
                  System.out.println(hoy); // 2025-05-09
                  System.out.println(nacimiento); // 2000-05-15

                  // Operaciones √∫tiles
                  System.out.println(hoy.getYear());      // 2025
                  System.out.println(hoy.plusDays(5));    // 2025-05-14
                  System.out.println(hoy.isAfter(nacimiento)); // true
                 </pre></code> 
                 <p> Otras clases √∫tiles<br>
                  ¬∑&nbsp;LocalTime: solo la hora (sin fecha).<br>
                  ¬∑&nbsp;LocalDateTime: fecha + hora.<br>
                  ¬∑&nbsp;Period: diferencia entre fechas.<br>
                  ¬∑&nbsp;DateTimeFormatter: para formatear fechas.
                 </p>
                 <code><pre>
                  import java.time.format.DateTimeFormatter;

                  DateTimeFormatter formato = DateTimeFormatter.ofPattern("dd/MM/yyyy");
                  System.out.println(hoy.format(formato)); // 09/05/2025
                 </pre></code>  
                 <table border="1" cellpadding="8" cellspacing="0">
                    <thead>
                      <tr>
                        <th>Tema</th>
                        <th>Clase</th>
                        <th>Uso principal</th>
                      </tr>
                                      </thead>
                    <tbody>
                      <tr>
                        <td>Cadenas</td>
                        <td><code>String</code></td>
                        <td>Texto inmutable</td>
                      </tr>
                      <tr>
                        <td>Cadenas eficientes</td>
                        <td><code>StringBuilder</code></td>
                        <td>Concatenaci√≥n y modificaci√≥n r√°pida</td>
                      </tr>
                      <tr>
                        <td>Fecha/Hora vieja</td>
                        <td><code>Date</code>, <code>Calendar</code></td>
                        <td>Representaci√≥n b√°sica (obsoleta)</td>
                      </tr>
                      <tr>
                        <td>Fecha moderna</td>
                        <td><code>LocalDate</code></td>
                        <td>Fecha sin hora (Java 8+)</td>
                      </tr>
                      <tr>
                        <td>Fecha + Hora</td>
                        <td><code>LocalDateTime</code></td>
                        <td>Fecha con hora</td>
                      </tr>
                      <tr>
                        <td>Formateo</td>
                        <td><code>DateTimeFormatter</code></td>
                        <td>Cambiar formato de fecha</td>
                      </tr>
                    </tbody>
                  </table>

               </div>
            </tema-item>
<!-- 14.Avanzado-PROGRAMACI√ìN FUNCIONAL.           -->
            <tema-item>
              <titulo>
                <strong>14.Avanzado-Programaci√≥n Funcional.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Programaci√≥n Funcional.</h2>
                 <h4>üîπ ¬øQu√© es la programaci√≥n funcional en Java?</h4>
                 <p>Es un estilo que trata las funciones como ciudadanos de primera clase, 
                    lo que permite pasar funciones como argumentos, devolverlas, almacenarlas 
                    en variables, etc. Java incorpora esto mediante:
                 </p>
               <p>
                ¬∑&nbsp;Expresiones lambda<br>
                ¬∑&nbsp;Interfaces funcionales<br>
                ¬∑&nbsp;Streams
               </p>
               <h4>üîπ 1. Expresiones Lambda</h4>
               <p>Permiten representar funciones an√≥nimas (sin nombre). Sintaxis:</p>
               <code><pre>
                (par√°metros) -> { cuerpo }
               </pre></code> 
               <p>Ejemplo:</p>
               <code><pre>
                // Tradicional
                Runnable r = new Runnable() {
                public void run() {
                System.out.println("Hola");
                }
               };

               // Con lambda
               Runnable r2 = () -> System.out.println("Hola");
               </pre></code>
               <h4>üîπ 2. Interfaces Funcionales</h4> 
               <p>Son interfaces que tienen solo un m√©todo abstracto. Se pueden usar con lambdas.</p>
               <p>‚úÖ Anotaci√≥n @FunctionalInterface</p>
               <code><pre>
                @FunctionalInterface
                interface Operacion {
                    int aplicar(int a, int b);
                }
               </pre></code> 
               <p>Interfaces comunes en java.util.function</p>
               <table border="1" cellpadding="8" cellspacing="0">
                  <thead>
                    <tr>
                      <th>Interfaz</th>
                      <th>Descripci√≥n</th>
                      <th>Ejemplo lambda</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><code>Predicate&lt;T&gt;</code></td>
                      <td>Devuelve <code>true</code> o <code>false</code></td>
                      <td><code>x -> x &gt; 5</code></td>
                    </tr>
                    <tr>
                      <td><code>Function&lt;T,R&gt;</code></td>
                      <td>Transforma un valor de tipo T en tipo R</td>
                      <td><code>x -> x.toString()</code></td>
                    </tr>
                    <tr>
                      <td><code>Consumer&lt;T&gt;</code></td>
                      <td>Ejecuta una acci√≥n sin devolver nada</td>
                      <td><code>x -> System.out.println(x)</code></td>
                    </tr>
                    <tr>
                      <td><code>Supplier&lt;T&gt;</code></td>
                      <td>Provee un valor sin recibir nada</td>
                      <td><code>() -> "Hola"</code></td>
                    </tr>
                    <tr>
                      <td><code>UnaryOperator&lt;T&gt;</code></td>
                      <td>Toma un valor y devuelve uno del mismo tipo</td>
                      <td><code>x -> x * x</code></td>
                    </tr>
                    <tr>
                      <td><code>BinaryOperator&lt;T&gt;</code></td>
                      <td>Opera con dos valores del mismo tipo T</td>
                      <td><code>(a, b) -> a + b</code></td>
                    </tr>
                  </tbody>
                </table>
                <h4>üîπ 3. API Stream</h4>
                <p>Permite trabajar con colecciones de forma funcional, declarativa y fluida.</p>
                <p>üî∏ Ejemplo b√°sico:</p>
                <code><pre>
                  import java.util.Arrays;
                  import java.util.List;
                  import java.util.stream.Collectors;

                  List<String> nombres = Arrays.asList("Ana", "Luis", "Pedro", "Ana");

                  // Filtrar, transformar a may√∫sculas y recolectar
                  List<String> resultado = nombres.stream()
                      .filter(n -> !n.equals("Ana"))        // Filtrar
                      .map(String::toUpperCase)             // Transformar
                      .collect(Collectors.toList());        // Recolectar

                  System.out.println(resultado); // [LUIS, PEDRO]
                </pre></code>
                <h4>üîπ 4. Operaciones comunes con Streams</h4>
                <table border="1" cellpadding="8" cellspacing="0">
                   <thead>
                     <tr>
                       <th>Operaci√≥n</th>
                       <th>Qu√© hace</th>
                       <th>Ejemplo</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td><code>filter()</code></td>
                       <td>Filtra elementos</td>
                       <td><code>.filter(x -> x &gt; 10)</code></td>
                                     </tr>
                     <tr>
                       <td><code>map()</code></td>
                       <td>Transforma elementos</td>
                       <td><code>.map(x -> x * 2)</code></td>
                     </tr>
                     <tr>
                       <td><code>collect()</code></td>
                       <td>Recolecta en una lista, set, etc.</td>
                       <td><code>.collect(Collectors.toList())</code></td>
                     </tr>
                     <tr>
                       <td><code>forEach()</code></td>
                       <td>Ejecuta acci√≥n por cada elemento</td>
                       <td><code>.forEach(System.out::println)</code></td>
                     </tr>
                     <tr>
                       <td><code>sorted()</code></td>
                       <td>Ordena los elementos</td>
                       <td><code>.sorted()</code></td>
                     </tr>
                     <tr>
                       <td><code>distinct()</code></td>
                       <td>Elimina duplicados</td>
                       <td><code>.distinct()</code></td>
                     </tr>
                     <tr>
                       <td><code>count()</code></td>
                       <td>Cuenta elementos</td>
                       <td><code>.count()</code></td>
                     </tr>
                     <tr>
                       <td><code>anyMatch()</code></td>
                       <td>¬øAlg√∫n elemento cumple condici√≥n?</td>
                       <td><code>.anyMatch(x -> x &lt; 0)</code></td>
                     </tr>
                   </tbody>
                </table>
                <h4>Ejemplo completo</h4>
                <code><pre>
                  import java.util.*;
                  import java.util.stream.*;

                  public class Ejemplo {
                      public static void main(String[] args) {
                          List<Integer> numeros = Arrays.asList(2, 3, 4, 5, 6, 7, 8);
                  
                          List<Integer> paresCuadrados = numeros.stream()
                              .filter(n -> n % 2 == 0)       // Solo pares
                              .map(n -> n * n)              // Cuadrado
                              .collect(Collectors.toList());

                          paresCuadrados.forEach(System.out::println); // 4, 16, 36, 64
                      }
                  }

                </pre></code> 
                <p></p>
                <code><pre>
                </pre></code> 
               </div>
            </tema-item>
<!-- 15.Avanzado-PROGRAMACI√ìN FUNCIONAL.           -->
            <tema-item>
              <titulo>
                <strong>15.Avanzado-Hilos y Concurrencia.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Hilos y Concurrencia.</h2>
                 <h4>üßµ ¬øQu√© es un hilo (thread)?</h4>
                 <p>Un hilo es una unidad de ejecuci√≥n dentro de un proceso. 
                    Java permite que m√∫ltiples hilos se ejecuten en paralelo, 
                    lo que se conoce como concurrencia.
                 </p>
                 <h4>üß± Formas de crear hilos en Java</h4>
                 <table border="1">
                     <thead>
                       <tr>
                         <th>M√©todo</th>
                         <th>C√≥mo se hace</th>
                       </tr>
                     </thead>
                     <tbody>
                       <tr>
                         <td><strong>Extender <code>Thread</code></strong></td>
                         <td>Crear una clase que hereda de <code>Thread</code> y sobrescribir <code>run()</code></td>
                       </tr>
                       <tr>
                         <td><strong>Implementar <code>Runnable</code></strong></td>
                         <td>Crear una clase que implementa <code>Runnable</code> y pasarla a un <code>Thread</code></td>
                       </tr>
                     </tbody>
                 </table>
                 <code><pre>
                  class MiHilo extends Thread {
                  public void run() {
                  System.out.println("Hola desde el hilo!");
                     }
                  }
                 </pre></code> 
                 <p>Ejemplo con Runnable:</p>
                 <code><pre>
                  class Tarea implements Runnable {
                  public void run() {
                  System.out.println("Ejecutando tarea...");
                    }
                  }

                 // Uso:
                 Thread hilo = new Thread(new Tarea());
                 hilo.start();
                 </pre></code> 
                 <h4>üß© synchronized, wait(), notify()</h4>  
                 <table border="1">
                      <thead>
                        <tr>
                          <th>Palabra clave</th>
                          <th>Funci√≥n</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td><code>synchronized</code></td>
                          <td>Evita que dos hilos accedan a una secci√≥n cr√≠tica al mismo tiempo</td>
                        </tr>
                        <tr>
                          <td><code>wait()</code></td>
                          <td>Hace que un hilo espere hasta que otro lo notifique</td>
                        </tr>
                        <tr>
                          <td><code>notify()</code> / <code>notifyAll()</code></td>
                          <td>Despierta uno o todos los hilos que est√°n esperando</td>
                        </tr>
                      </tbody>
                 </table>
                 <p>Ejemplo simple:</p>
                 <code><pre>
                  synchronized(obj) {
                       while (!condicion) {
                           obj.wait();
                       }
                      // hacer algo
                      obj.notify(); // o notifyAll()
                  }
                 </pre></code> 
                 <h4>‚öôÔ∏è ExecutorService (desde Java 5)</h4>
                 <p>Es una interfaz que gestiona un pool de hilos, lo que permite 
                    ejecutar tareas de manera m√°s eficiente que crear hilos manualmente.
                 </p>
                 <p>Ejemplo con ExecutorService:</p>
                 <code><pre>
                  import java.util.concurrent.*;

                  ExecutorService executor = Executors.newFixedThreadPool(2);

                  executor.execute(() -> System.out.println("Tarea 1"));
                  executor.execute(() -> System.out.println("Tarea 2"));

                  executor.shutdown(); // No acepta m√°s tareas
                 </pre></code> 
                 <h4>üö¶ ¬øQu√© es la programaci√≥n concurrente?</h4>
                 <p>Es un paradigma donde m√∫ltiples tareas se ejecutan al mismo tiempo, ya sea de forma paralela 
                    (con m√∫ltiples n√∫cleos) o intercalada (un solo n√∫cleo compartido).
                 </p>
                 <h4>‚úÖ Ventajas de la concurrencia:</h4>
                 <p>
                  ¬∑&nbsp;Mejor uso de CPU multin√∫cleo.<br>
                  ¬∑&nbsp;Mayor rendimiento en tareas como servidores web, procesamiento paralelo, etc.
                 </p>
                 <h4>Desaf√≠os:</h4>
                 <p>
                  ¬∑&nbsp;Condiciones de carrera.<br>
                  ¬∑&nbsp;Bloqueos (deadlocks).<br>
                  ¬∑&nbsp;Dificultad de depuraci√≥n.
                 </p>
               </div>
            </tema-item>
<!-- 16.Avanzado-ENTRADA Y SALIDA.           -->
            <tema-item>
              <titulo>
                <strong>16.Avanzado-Entrada y Salida.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Entrada y Salida  de archivos en Java (I/O).</h2>
                 <p>Java proporciona dos grandes grupos de clases para trabajar con archivos:</p>
                 <h4>1. Flujos de bytes (Streams)</h4>
                 <p>Se usan para leer y escribir datos binarios (im√°genes, videos, etc.)</p>
                 <table border="1">
                    <thead>
                      <tr>
                        <th>Clase</th>
                        <th>Uso</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>InputStream</code></td>
                        <td>Leer bytes desde una fuente</td>
                      </tr>
                      <tr>
                        <td><code>OutputStream</code></td>
                        <td>Escribir bytes a un destino</td>
                      </tr>
                    </tbody>
                 </table>
                 <p>Ejemplo:</p>
                 <code><pre>
                  FileInputStream fis = new FileInputStream("archivo.txt");
                  int dato = fis.read();
                  fis.close();
                 </pre></code>
                 <h4>2. Flujos de caracteres (Readers/Writers)</h4> 
                 <p>Se usan para leer y escribir texto (caracteres Unicode).</p>

                 <p>Ejemplo:</p>
                 <table border="1">
                   <thead>
                     <tr>
                       <th>Clase</th>
                       <th>Uso</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                                        <td><code>Reader</code></td>
                       <td>Leer caracteres desde una fuente</td>
                     </tr>
                     <tr>
                       <td><code>Writer</code></td>
                       <td>Escribir caracteres a un destino</td>
                     </tr>
                   </tbody>
                 </table>
                 <code><pre>
                  FileWriter fw = new FileWriter("salida.txt");
                  fw.write("Hola Mundo");
                  fw.close();
                 </pre></code>
                 <h4>üíæ Serializaci√≥n de objetos</h4> 
                 <p>La serializaci√≥n permite convertir un objeto en una secuencia de bytes 
                    para guardarlo en un archivo o enviarlo por red, y luego reconstruirlo.
                 </p>
                 <h4>1. ¬øC√≥mo se serializa?</h4>
                 <p>
                   ¬∑&nbsp;La clase debe implementar Serializable.<br>
                   ¬∑&nbsp;Se usa ObjectOutputStream para guardar, y ObjectInputStream para leer.
                 </p>
                 <p>
                  Ejemplo de serializaci√≥n:
                 </p>
                 <code><pre>
                  import java.io.*;

                  class Persona implements Serializable {
                       String nombre;
                       int edad;
                      }

                       Persona p = new Persona(); 
                       p.nombre = "Ana";
                       p.edad = 30;

                       // Guardar objeto
                       ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("persona.dat"));
                       oos.writeObject(p);
                       oos.close();
                 </pre></code>
                 <p>Ejemplo de deserializaci√≥n:</p> 
                 <code><pre>
                  ObjectInputStream ois = new ObjectInputStream(new FileInputStream("persona.dat"));
                  Persona recuperada = (Persona) ois.readObject();
                  ois.close();
                 </pre></code>
                 <h4>üß† Resumen de clases clave</h4> 
               <table border="1">
                  <thead>
                    <tr>
                      <th>Tipo</th>
                     <th>Clase principal</th>
                     <th>Uso com√∫n</th>
                   </tr>
                 </thead>
                 <tbody>
                   <tr>
                     <td>Bytes</td>
                     <td><code>InputStream</code> / <code>OutputStream</code></td>
                     <td>Archivos binarios</td>
                   </tr>
                   <tr>
                     <td>Caracteres</td>
                      <td><code>Reader</code> / <code>Writer</code></td>
                      <td>Archivos de texto</td>
                    </tr>
                    <tr>
                      <td>Serializaci√≥n</td>
                      <td><code>ObjectInputStream</code> / <code>ObjectOutputStream</code></td>
                      <td>Guardar/cargar objetos</td>
                    </tr>
                  </tbody>
                 </table>
                 </div>
            </tema-item>
<!-- 17.Avanzado-Anotaciones.           -->
            <tema-item>
              <titulo>
                <strong>17.Avanzado-Anotaciones.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Anotaciones en Java.</h2>
                 <p>Las anotaciones (annotations) son etiquetas especiales en el c√≥digo que agregan
                    metainformaci√≥n y pueden ser utilizadas por el compilador o en tiempo de ejecuci√≥n 
                    (por ejemplo, con reflexi√≥n).
                  </p>
                  <h5>üìå Anotaciones comunes</h5>
                  <table border="1">
                    <thead>
                     <tr>
                       <th>Anotaci√≥n</th>
                        <th>¬øQu√© hace?</th>
                     </tr>
                   </thead>
                   <tbody>
                     <tr>
                       <td><code>@Override</code></td>
                       <td>Indica que un m√©todo est√° sobrescribiendo uno heredado. Ayuda a detectar errores de escritura.</td>
                     </tr>
                     <tr>
                       <td><code>@Deprecated</code></td>
                       <td>Marca un elemento como obsoleto; no debe usarse en c√≥digo nuevo.</td>
                     </tr>
                     <tr>
                       <td><code>@SuppressWarnings</code></td>
                        <td>Suprime advertencias del compilador, por ejemplo, por uso de tipos sin gen√©ricos.</td>
                      </tr>
                    </tbody>
                  </table>
                  <p>Ejemplo:</p>
                  <code><pre>
                    class Animal {
                        void sonido() {}
                    }

                    class Perro extends Animal {
                        @Override
                        void sonido() {
                            System.out.println("Guau");
                    }

                        @Deprecated
                        void metodoViejo() {
                            System.out.println("Obsoleto");
                        }
                    }
                  </pre></code> 
                  <h3>üß© Anotaciones personalizadas</h3>
                  <p>Puedes crear tus propias anotaciones con @interface.</p>
                  <p>Ejemplo de anotaci√≥n personalizada:</p>
                  <code><pre>
                     @interface Informacion {
                          String autor();
                          String fecha();
                        }
                  </pre></code> 
                  <p>Usando la anotaci√≥n:</p>
                  <code><pre>
                    @Informacion(autor = "Juan", fecha = "2025-05-09")
                    public class Demo {}
                  </pre></code>
                  <h3>üîç Procesamiento con reflexi√≥n</h3>
                  <p>Puedes leer anotaciones en tiempo de ejecuci√≥n usando reflexi√≥n:</p>
                  <code><pre>
                    import java.lang.reflect.*;

                    public class Main {
                         public static void main(String[] args) {
                             Class<?> clase = Demo.class;

                             if (clase.isAnnotationPresent(Informacion.class)) {
                             Informacion info = clase.getAnnotation(Informacion.class);
                             System.out.println("Autor: " + info.autor());
                             System.out.println("Fecha: " + info.fecha());
                           }
                          }
                        }
                  </pre></code> 
                  <h4>Resumen.</h4>
                   <table border="1">
                     <thead>
                       <tr>
                         <th>Tema</th>
                         <th>Descripci√≥n</th>
                       </tr>
                     </thead>
                     <tbody>                    
                       <tr>
                         <td><code>@Override</code></td>
                        <td>Verifica que se est√° sobrescribiendo correctamente</td>
                      </tr>
                      <tr>
                        <td><code>@Deprecated</code></td>
                        <td>Marca m√©todos/clases obsoletos</td>
                      </tr>
                       <tr>
                        <td><code>Anotaciones personalizadas</code></td>
                        <td>Permite definir etiquetas propias para clases, m√©todos, etc.</td>
                      </tr>
                      <tr>
                        <td><code>Reflexi√≥n</code></td>
                        <td>Permite inspeccionar clases y leer anotaciones en tiempo de ejecuci√≥n</td>
                      </tr>
                     </tbody>
                   </table>
               </div>
            </tema-item>
<!-- 18.Avanzado-Reflexi√≥n y metadatos.           -->
            <tema-item>
              <titulo>
                <strong>18.Avanzado-Reflexi√≥n y Metadatos.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Reflexi√≥n y Metadatos.</h2>
                 <p>En Java, reflexi√≥n (reflection) es una poderosa caracter√≠stica que permite 
                    a los programas inspeccionar y manipular clases, interfaces, campos y m√©todos 
                    en tiempo de ejecuci√≥n, incluso si no se conoc√≠an en tiempo de compilaci√≥n. 
                    Esto se logra a trav√©s del paquete java.lang.reflect.
                 </p>
                 <h4>üß† ¬øPara qu√© sirve la reflexi√≥n?</h4>
                 <p>
                  ¬∑&nbsp;Obtener informaci√≥n sobre clases, m√©todos, campos y constructores.<br>
                  ¬∑&nbsp;Crear objetos de clases din√°micamente.<br>
                  ¬∑&nbsp;Llamar m√©todos o acceder a campos privados.<br>
                  ¬∑&nbsp;Leer anotaciones (metadatos) en clases, m√©todos, etc.
                 </p>
                 <h4>üîç Principales clases del paquete java.lang.reflect</h4>
                 <table>
                    <thead>
                      <tr>
                        <th>Clase</th>
                        <th>Funci√≥n principal</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td><code>Class</code></td>
                        <td>Representa cualquier clase o interfaz en Java.</td>
                      </tr>
                      <tr>
                        <td><code>Field</code></td>
                                          <td>Representa atributos o variables de instancia.</td>
                      </tr>
                      <tr>
                        <td><code>Method</code></td>
                        <td>Representa un m√©todo declarado en una clase.</td>
                      </tr>
                      <tr>
                        <td><code>Constructor</code></td>
                        <td>Representa un constructor de una clase.</td>
                      </tr>
                      <tr>
                        <td><code>Modifier</code></td>
                        <td>Permite analizar modificadores (public, static...).</td>
                      </tr>
                   </tbody>
                 </table>
                 <p>üß™ Ejemplo b√°sico de reflexi√≥n:</p>
                 <code><pre>
                  import java.lang.reflect.*;

                  public class Prueba {
                      private String mensaje = "Hola";
                  
                      public void saludar() {
                          System.out.println(mensaje);
                      }
                  
                      public static void main(String[] args) throws Exception {
                          Class<?> clase = Class.forName("Prueba");
                  
                          Object obj = clase.getDeclaredConstructor().newInstance();
                  
                          Field campo = clase.getDeclaredField("mensaje");
                          campo.setAccessible(true); // Acceder a campo privado
                          campo.set(obj, "Hola con reflexi√≥n!");
                  
                          Method metodo = clase.getDeclaredMethod("saludar");
                          metodo.invoke(obj); // Imprime: Hola con reflexi√≥n!
                      }
                  }
                 </pre></code>
                 <h4>üè∑Ô∏è ¬øQu√© son los metadatos?</h4> 
                 <p>Son informaci√≥n adicional sobre el c√≥digo, usualmente representada mediante 
                    anotaciones (@Override, @Deprecated, etc.). Con reflexi√≥n, puedes leer 
                    anotaciones en tiempo de ejecuci√≥n.
                 </p>
                 <h4>üß∞ Casos comunes de uso:</h4>
                 <p>
                  ¬∑&nbsp;Frameworks como Spring o Hibernate.<br>
                  ¬∑&nbsp;Inyecci√≥n de dependencias.<br>
                  ¬∑&nbsp;Sistemas de serializaci√≥n y deserializaci√≥n.<br>
                  ¬∑&nbsp;Sistemas de pruebas automatizadas (JUnit).
                 </p>
                 <h4>Ejemplo Reflexi√≥n y Anotaciones Personalizadas</h4>
                 <p>üéØ Objetivo:<br>
                  ¬∑&nbsp;Crear una anotaci√≥n personalizada llamada @Informacion.<br>
                  ¬∑&nbsp;Aplicarla a una clase y a un m√©todo.<br>
                  ¬∑&nbsp;Usar reflexi√≥n para leer esa anotaci√≥n en tiempo de ejecuci√≥n.
                 </p>
                 <h4>Paso 1: Definir la anotaci√≥n</h4>
                 <code><pre>
                  import java.lang.annotation.*;

                  @Retention(RetentionPolicy.RUNTIME)
                  @Target({ElementType.TYPE, ElementType.METHOD})
                  public @interface Informacion {
                  String autor();
                  String fecha();
                  }
                 </pre></code> 
                 <p>
                   ¬∑&nbsp;@Retention(RetentionPolicy.RUNTIME): hace que la anotaci√≥n est√© disponible en tiempo de ejecuci√≥n.<br>
                   ¬∑&nbsp;@Target(...): define d√≥nde se puede usar la anotaci√≥n (clases, m√©todos, etc.).
                 </p>
                 <h4>Paso 2: Usar la anotaci√≥n</h4>
                 <code><pre>
                  @Informacion(autor = "Juan", fecha = "2025-05-09")
                  public class Demo {

                       @Informacion(autor = "Juan", fecha = "2025-05-09")
                       public void saludar() {
                           System.out.println("Hola mundo");
                        }
                  }
                 </pre></code> 
                 <h4> Paso 3: Leer la anotaci√≥n con reflexi√≥n</h4>
                 <code><pre>
                  import java.lang.reflect.*;

                  public class LectorAnotacion {
                      public static void main(String[] args) {
                          try {
                              Class<?> clase = Demo.class;
                  
                              // Leer anotaci√≥n de la clase
                              if (clase.isAnnotationPresent(Informacion.class)) {
                                  Informacion info = clase.getAnnotation(Informacion.class);
                                  System.out.println("Clase - Autor: " + info.autor() + ", Fecha: " + info.fecha());
                              }
                  
                              // Leer anotaci√≥n del m√©todo
                              Method metodo = clase.getDeclaredMethod("saludar");
                              if (metodo.isAnnotationPresent(Informacion.class)) {
                                  Informacion infoMetodo = metodo.getAnnotation(Informacion.class);
                                  System.out.println("M√©todo - Autor: " + infoMetodo.autor() + ", Fecha: " + infoMetodo.fecha());
                              }
                  
                          } catch (Exception e) {
                              e.printStackTrace();
                          }
                      }
                  }
                 </pre></code> 
                 <p>üßæ Salida esperada:</p>
                 <code><pre>
                  Clase - Autor: Juan, Fecha: 2025-05-09
                  M√©todo - Autor: Juan, Fecha: 2025-05-09
                 </pre></code> 
               </div>
            </tema-item>
<!-- 19.Avanzado-M√≥dulos(desde Java 9).           -->
            <tema-item>
              <titulo>
                <strong>19.Avanzado-M√≥dulos (desde Java 9).</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>M√≥dulos desde Java 9.</h2>
                 <h4>üî∑ ¬øQu√© es un m√≥dulo en Java?</h4>
                 <p>Un m√≥dulo es una unidad de encapsulamiento de c√≥digo que agrupa 
                    paquetes y recursos. Cada m√≥dulo declara qu√© paquetes expone y 
                    qu√© dependencias necesita mediante el archivo module-info.java.
                 </p>
                 <h4></h4>
                 <code><pre>
                  mi-aplicacion/
                  ‚îú‚îÄ‚îÄ module-info.java
                  ‚îú‚îÄ‚îÄ com/
                  ‚îÇ   ‚îî‚îÄ‚îÄ ejemplo/
‚îÇ                 ‚îî‚îÄ‚îÄ Saludo.java
                 </pre></code> 
                 <p>üßæ Ejemplo de module-info.java</p>
                 <code><pre>
                  module com.ejemplo.saludo {
                     exports com.ejemplo;            // Expone el paquete com.ejemplo
                     requires java.sql;              // Requiere el m√≥dulo java.sql
                  }
                 </pre></code> 
                 <p>
                   ¬∑&nbsp;exports: hace visible un paquete a otros m√≥dulos.<br>
                   ¬∑&nbsp;requires: indica que este m√≥dulo depende de otro.
                 </p>
                 <h4>üß© Encapsulamiento de paquetes</h4>
                 <p>Con m√≥dulos:<br>
                   ¬∑&nbsp;Solo los paquetes exportados en module-info.java son accesibles desde otros m√≥dulos.<br>
                   ¬∑&nbsp;Los dem√°s paquetes quedan encapsulados, es decir, no se pueden usar fuera del m√≥dulo, aunque sean public.<br>
                   Esto refuerza la ocultaci√≥n y reduce dependencias innecesarias.
                 </p> 
                 <h4>üéØ Ventajas del sistema de m√≥dulos</h4>
                 <code><pre>
                  <table border="1">
                    <thead>
                      <tr>
                        <th>Ventaja</th>
                        <th>Descripci√≥n</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Encapsulamiento fuerte</td>
                        <td>Oculta detalles internos no exportados.</td>
                      </tr>
                      <tr>
                        <td>Carga m√°s r√°pida</td>
                        <td>Solo se cargan los m√≥dulos necesarios.</td>
                      </tr>
                      <tr>
                        <td>Dependencias claras</td>
                        <td>Declara expl√≠citamente qu√© m√≥dulos necesita.</td>
                      </tr>
                      <tr>
                        <td>Seguridad mejorada</td>
                        <td>Menos superficie de ataque al ocultar APIs no necesarias.</td>
                      </tr>
                    </tbody>
                  </table>
                 </pre></code> 
               </div>
            </tema-item>
<!-- 20.Avanzado-Buenas pr√°cticas y patrones de dise√±o.           -->
            <tema-item>
              <titulo>
                <strong>20.Avanzado-Buenas P≈ïacticas y Patrones de Dise√±o.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Buenas Pr√°cticas y Patrones de Dise√±o.</h2>
                 <p>
                  ¬∑&nbsp;Nombres claros: Usa nombres descriptivos para clases, m√©todos y variables.<br>
                  ¬∑&nbsp;Una clase, una responsabilidad: Mant√©n las clases enfocadas en una tarea.<br>
                  ¬∑&nbsp;Evita duplicaci√≥n de c√≥digo: Reutiliza m√©todos y abstrae l√≥gica repetida.<br>
                  ¬∑&nbsp;Usa colecciones adecuadas: Elige entre List, Set, Map seg√∫n el caso.<br>
                  ¬∑&nbsp;Manejo adecuado de excepciones: Usa try-catch solo cuando sea necesario.
                 </p>
                <h4>üß± Principios SOLID</h4> 
                <table border="1">
                 <thead>
                    <tr>
                     <th>Letra</th>
                     <th>Principio</th>
                     <th>Descripci√≥n breve</th>
                   </tr>
                 </thead>
                 <tbody>
                   <tr>
                     <td>S</td>
                     <td><strong>Single Responsibility</strong></td>
                      <td>Una clase debe tener una √∫nica raz√≥n para cambiar.</td>
                   </tr>
                   <tr>
                     <td>O</td>
                     <td><strong>Open/Closed</strong></td>
                     <td>Abierto a extensi√≥n, cerrado a modificaci√≥n.</td>
                   </tr>
                   <tr>
                     <td>L</td>
                     <td><strong>Liskov Substitution</strong></td>
                     <td>Una subclase debe poder usarse como su clase padre sin alterar el comportamiento.</td>
                   </tr>
                   <tr>
                     <td>I</td>
                      <td><strong>Interface Segregation</strong></td>
                     <td>No forzar a implementar interfaces con m√©todos que no se necesitan.</td>
                    </tr>
                    <tr>
                      <td>D</td>
                      <td><strong>Dependency Inversion</strong></td>
                      <td>Depender de abstracciones, no de implementaciones concretas.</td>
                    </tr>
                  </tbody>
                </table>
                <h4>üßπ Limpieza de C√≥digo</h4>
                <p>
                  ¬∑&nbsp;Divide m√©todos largos en funciones peque√±as con nombres claros.<br>
                  ¬∑&nbsp;Evita comentarios innecesarios: el c√≥digo limpio se explica por s√≠ solo.<br>
                  ¬∑&nbsp;Elimina c√≥digo muerto (no usado).<br>
                  ¬∑&nbsp;Aplica consistencia en estilo y formato.
                </p>
                <h4>üîß Refactorizaci√≥n</h4>
               <p>Es el proceso de mejorar la estructura del c√≥digo sin cambiar su funcionalidad:</p>
               <p>
                ¬∑&nbsp;Extraer m√©todos repetidos.<br>
                ¬∑&nbsp;Renombrar variables para mejor comprensi√≥n.<br>
                ¬∑&nbsp;Aplicar patrones donde sea necesario.<br>
                ¬∑&nbsp;Simplificar condicionales complejos.
               </p>
               </div>
            </tema-item>
<!-- 21.Avanzado-Pruebas con JUnit.           -->
            <tema-item>
              <titulo>
                <strong>21.Avanzado-Pruebas con JUnit.</strong><br>
                 <br>
                <strong></strong>
              </titulo>
              <subtitulo></subtitulo>
               <div>
                 <h2>Pruebas con JUnit.</h2>
                 <h4>üîπ ¬øQu√© es JUnit?</h4>
                 <p>JUnit es un framework para escribir pruebas unitarias en Java. 
                    Permite verificar que los m√©todos de una clase funcionan correctamente.
                 </p>
                 <h4>üîπ Anotaciones principales de JUnit</h4>
                 <table border="1">
                   <tr>
                      <th>Anotaci√≥n</th>
                      <th>Prop√≥sito</th>
                    </tr>
                    <tr>
                      <td><code>@Test</code></td>
                      <td>Marca un m√©todo como prueba.</td>
                    </tr>
                    <tr>
                      <td><code>@BeforeEach</code></td>
                      <td>Se ejecuta <strong>antes</strong> de cada prueba. (Inicializaci√≥n)</td>
                    </tr>
                    <tr>
                      <td><code>@AfterEach</code></td>
                      <td>Se ejecuta <strong>despu√©s</strong> de cada prueba. (Limpieza)</td>
                    </tr>
                   <tr>
                     <td><code>@BeforeAll</code></td>
                     <td>Se ejecuta <strong>una vez</strong> antes de todas las pruebas (requiere <code>static</code>).</td>
                   </tr>
                    <tr>
                      <td><code>@AfterAll</code></td>
                      <td>Se ejecuta <strong>una vez</strong> despu√©s de todas las pruebas (requiere <code>static</code>).</td>
                    </tr>
                 </table>
                 <h4>üîπ M√©todos assert comunes (JUnit)</h4>
                 <table border="1">
                  <tr>
                    <th>M√©todo</th>
                    <th>Qu√© hace</th>
                  </t>
                  <tr>
                    <td><code>assertEquals(a, b)</code></td>
                    <td>Verifica que <code>a</code> y <code>b</code> son iguales</td>
                  </tr>
                   <tr>
                     <td><code>assertTrue(condici√≥n)</code></td>
                     <td>Verifica que la condici√≥n es verdadera</td>
                   </tr>
                   <tr>
                     <td><code>assertFalse(condici√≥n)</code></td>
                    <td>Verifica que la condici√≥n es falsa</td>
                  </tr>
                  <tr>
                    <td><code>assertThrows()</code></td>
                    <td>Verifica que se lanza una excepci√≥n</td>
                  </tr>
                  <tr>
                    <td><code>assertNotNull(obj)</code></td>
                     <td>Verifica que el objeto no sea <code>null</code></td>
                   </tr>
                </table>
                 <p>üîπ Ejemplo b√°sico con JUnit 5</p>
                 <code><pre>
                  import org.junit.jupiter.api.*;

                  import static org.junit.jupiter.api.Assertions.*;

                  class CalculadoraTest {
                  
                      Calculadora calc;
                  
                     @BeforeEach
                     void setUp() {
                         calc = new Calculadora();
                     }
                  
                      @Test
                      void sumaDebeSerCorrecta() {
                          assertEquals(5, calc.sumar(2, 3));
                      }
                  
                     @Test
                     void divisionPorCeroLanzaExcepcion() {
                         assertThrows(ArithmeticException.class, () -> calc.dividir(5, 0));
                     }
                  
                     @AfterEach
                     void tearDown() {
                         calc = null;
                     }
                  }
                 </pre></code>
                 <h4>üîπ ¬øQu√© es Mockito?</h4> 
                 <p>Mockito es una librer√≠a para crear mocks o simulacros: objetos falsos 
                    que imitan el comportamiento de dependencias reales para pruebas aisladas.
                 </p>
                 <h4>üîπ Conceptos clave de Mockito</h4>
                 <table border="1">
                   <tr>
                     <th>Funci√≥n</th>
                     <th>Descripci√≥n</th>
                   </tr>
                   <tr>
                     <td><code>mock(Clase.class)</code></td>
                     <td>Crea un objeto simulado.</td>
                   </tr>
                   <tr>
                     <td><code>when(...).thenReturn(...)</code></td>
                     <td>Define qu√© devolver cuando se llama a un m√©todo simulado.</td>
                   </tr>
                   <tr>
                     <td><code>verify(mock)</code></td>
                     <td>Verifica que un m√©todo fue llamado en el mock.</td>
                   </tr>
                 </table>
                 <p>üîπ Ejemplo con Mockito</p>
                 <code><pre>
                  import static org.mockito.Mockito.*;
                  import org.junit.jupiter.api.Test;
                  import java.util.List;

                  public class EjemploMockito {
                  
                      @Test
                      void pruebaMockLista() {
                          List<String> listaMock = mock(List.class);
                  
                          when(listaMock.get(0)).thenReturn("Hola");
                  
                          assertEquals("Hola", listaMock.get(0));
                  
                          verify(listaMock).get(0);
                      }
                  }
                 </pre></code>
                 <h4>Resumen.</h4>
                 <code><pre>
                  <table border="1">
                     <tr>
                      <th>Concepto</th>
                       <th>Descripci√≥n</th>
                       <th>Ejemplo</th>
                     </tr>
                     <tr>
                       <td>Mock</td>
                       <td>Objeto simulado que imita el comportamiento de una clase real.</td>
                       <td><code>MiServicio mock = mock(MiServicio.class);</code></td>
                     </tr>
                    <tr>
                       <td>Stubbing</td>
                       <td>Definir qu√© debe devolver un m√©todo simulado.</td>
                       <td><code>when(mock.metodo()).thenReturn("Valor");</code></td>
                     </tr>
                     <tr>
                       <td>Verificaci√≥n</td>
                       <td>Comprobar que se llam√≥ a un m√©todo espec√≠fico.</td>
                       <td><code>verify(mock).metodo();</code></td>
                     </tr>
                     <tr>
                       <td>ArgumentMatchers</td>
                       <td>Permite usar valores gen√©ricos en stubs o verificaciones.</td>
                       <td><code>when(mock.metodo(anyInt())).thenReturn("ok");</code></td>
                                       </tr>
                                       <tr>
                       <td>Inyecci√≥n de mocks</td>
                       <td>Mocks que se inyectan autom√°ticamente en la clase a probar.</td>
                       <td><code>@InjectMocks</code> + <code>@Mock</code></td>
                     </tr>
                     <tr>
                       <td>Spy</td>
                       <td>Parcialmente real: permite usar m√©todos reales y simular algunos.</td>
                       <td><code>SpyList spy = spy(new ArrayList());</code></td>
                     </tr>
                  </table>
                 </pre></code> 
                 <!-- <p></p>
                 <code><pre>
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code> 
                 <p></p>
                 <code><pre>
                 </pre></code>  -->
               </div>
            </tema-item>                                              
         </mi-lista>

    </main>
    <footer class="footer">
        <mi-footer></mi-footer>
      </footer>
      <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
      <script src="js/nav.js"defer></script>
      <script src="js/footer.js" defer></script>
      <script src="js/lista.js"></script>
</body>
</html>