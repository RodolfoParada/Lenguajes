<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/index.css" />
    <title>Javascript</title>

</head>

<body>
    <nav class="mb-5">
        <mi-navegacion></mi-navegacion>
    </nav>
    <main>
        <div class="hidden">Este texto será ocultado.</div>
        <div class="js-text mx-5">Javascript</div>

        <mi-lista class="overflow-scroll">
<!-- 1.Introducción Javascript     -->
            <tema-item>
                <titulo>
                    <strong>1. Introducción:</strong><br>
                    ¿Qué es JavaScript?,<br>
                    <strong>Cómo funciona</strong>, instalación
                </titulo>
                  <subtitulo></subtitulo>
                <div>
                    <h2>Qué es JavaScript?</h2>
                    <p>JavaScript (JS) es un lenguaje de programación de alto nivel, interpretado y orientado a objetos,
                        que se utiliza principalmente para crear páginas web <br>interactivas. Junto con HTML y CSS , forma
                        el núcleo de las tecnologías del desarrollo web frontend y CSS, forma el núcleo de las
                        tecnologías del desarrollo<br> web frontend.</p>
                    <h2>¿Para qué sirve?</h2>
                    <p>·&nbsp;Manipular el contenido de las páginas web (DOM).<br>·&nbsp;Validar
                        formularios.<br>·&nbsp;Gestionar eventos del usuario.<br>·&nbsp;Realizar peticiones al servidor
                        (AJAX / fetch).<br>·&nbsp;Desarrollar aplicaciones web completas (gracias a frameworks como
                        React, Vue o Angular).<br>·&nbsp;También se usa del lado del servidor con Node.js.</p>
                    <h2>Cómo funciona JavaScript en el navegador.</h2>
                    <h3>1.&nbsp;Motor de JavaScript.</h3>
                    <p>·&nbsp;V8 en Google Chrome y Opera.<br>·&nbsp;SpiderMonkey en Mozilla
                        Firefox.<br>·&nbsp;JavaScriptCore (también conocido como Nitro) en Safari.<br>·&nbsp;Chakra en
                        versiones antiguas de Microsoft Edge.</p>
                    <p>Estos motores toman el código JavaScript, lo interpretan y, en muchos casos, lo compilan justo a
                        tiempo (JIT, Just-In-Time) para optimizar el rendimiento.</p>
                    <h3>2.&nbsp;Proceso de Carga y Ejecución</h3>
                    <p class="mb-1"><b>a) Carga y Parsing del HTML.</b></p>
                    <p class="mb-1">Cuando visitas una página web, el navegador realiza lo siguiente:</p>
                    <p>·&nbsp;Descarga del HTML: El navegador descarga el documento HTML, que puede contener etiquetas
                        script.<br>·&nbsp;Construcción del DOM: El HTML se analiza y se transforma en un árbol de nodos
                        llamado Document Object Model (DOM), que representa la estructura de<br> la página.</p>
                    <p class="mb-1"><b>b) Carga y Ejecución de JavaScript</b></p>
                    <p class="mb-1">El código JavaScript puede incluirse de diferentes formas:</p>
                    <p>·&nbsp;Código en línea (inline): Directamente en el HTML dentro de una etiqueta
                        script.<br>·&nbsp;Archivos externos: A través de etiquetas
                        <script src="archivo.js"></script>.
                    </p>
                    <p class="mb-1">El navegador puede ejecutar el código de formas distintas según cómo se carguen los
                        scripts:</p>
                    <p><b>Sin atributos adicionales:</b>El navegador detiene el parsing del HTML, descarga y ejecuta el
                        script, y luego continúa con el rendering.<br><b>Con defer:</b> El script se descarga en
                        paralelo, pero su ejecución se difiere hasta que el DOM esté completamente construido.<br><b>Con
                            async:</b> El script se descarga de manera asíncrona y se ejecuta tan pronto como esté
                        listo, lo que puede ocurrir en cualquier momento durante la carga de<br> la página.</p>
                    <h3>3. Interacción con el DOM y Web APIs</h3>
                    <p class="mb-1">Mientras se ejecuta el código JavaScript, puede interactuar con el contenido de la
                        página a través del DOM. Esto permite:</p>
                    <p><b>Manipulación del contenido:</b> Agregar, eliminar o modificar elementos HTML.<br><b>Estilos y
                            animaciones:</b> Cambiar clases o aplicar estilos dinámicos a los elementos.<br><b>Gestión
                            de eventos:</b> Registrar eventos (por ejemplo, clics, movimientos de mouse, entradas de
                        teclado) y definir funciones que se ejecuten cuando ocurran<br> esos eventos.</p>
                    <p class="mb-1">Además del DOM, los navegadores proporcionan un conjunto de Web APIs que expanden la
                        funcionalidad de JavaScript, como:</p>
                    <p>·&nbsp;APIs para peticiones AJAX/fetch: Para comunicarse con servidores sin recargar la
                        página.<br>·&nbsp;APIs para almacenamiento local: Como localStorage y
                        sessionStorage.<br>·&nbsp;APIs para multimedia: Manipular audio y video.<br>·&nbsp;APIs
                        gráficas: Como Canvas o WebGL para gráficos en 2D y 3D.</p>
                    <h4>4.&nbsp;Modelo de Concurrencia y Event Loop</h4>
                    <p>JavaScript en el navegador se ejecuta en un único hilo (single-threaded). Para manejar
                        operaciones asíncronas y mantener la interfaz responsiva, se utiliza el<br> event loop, que funciona
                        de la siguiente manera:</p>
                    <p>1.&nbsp;Call Stack: Es una pila donde se ubican todas las funciones que se van a ejecutar. Cuando
                        una función es llamada, se añade a la pila y, al finalizar, se retira.<br>2.&nbsp;Web APIs:
                        Operaciones asíncronas (como temporizadores con setTimeout, peticiones AJAX, etc.) se delegan a
                        las APIs del navegador.<br>3.&nbsp;Colas de tareas y microtareas: Una vez que las operaciones
                        asíncronas completan, sus callbacks se colocan en una cola de tareas o microtareas para ser<br>
                        ejecutadas una vez que la pila se vacíe.<br>4.&nbsp;Event Loop: Es el mecanismo que supervisa el
                        call stack y la cola, ejecutando los callbacks cuando la pila está libre.</p>
                    <p>Este mecanismo permite que, aunque JavaScript sea single-threaded, se pueda trabajar de manera
                        eficiente sin bloquear la interfaz del usuario.</p>
                    <h2>Como usar Javascript en un Proyecto</h2>
                    <p>Crear un archivo .js y luego importarlo en el archivo html con la
                        estiqueta.<b>script</b><br>también se puede usar con modulo hay que agregar dentro del script la
                        palabra reservada<b>module.</b><br>Si lo vas a subir a un repositorio github debes incorporar en
                        el script la palabra reservada <b>defer.</b></p>
                    <h3>Como dato adicional instalación de bootstrap</h3>
                    <p>Puedes agregar esto en el html</p>
                    <pre>
                    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css" rel="stylesheet"<br> integrity="sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7" crossorigin="anonymous"&gt;
                    &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js" <br>integrity="sha384-k6d4wzSIapyDyv1kpU366/PK5hCdSbCRGRCMv+eplOQJWyd1fbcAu9OCUj5zNLiq" crossorigin="anonymous"&gt;&lt;/script&gt;
                </pre>
                    <p>Se puede actualizar y lo puedes encontrar en la página de Bootstrap.<br>
                        Ir a <a href="https://getbootstrap.com/" target="_blank" rel="noopener noreferrer">Bootstrap</a>
                    </p>
                </div>
            </tema-item>
<!-- 2.Básico Sintaxis y Tipo de datos -->
            <tema-item>
                <titulo>
                    <strong>2. Básico Sintaxis</strong><br>
                    y Tipos de Datos.<br>
                    <strong></strong>
                  </titulo>
                  <subtitulo></subtitulo>
                  <div>
                <h2>Sintaxis y Tipos de Datos.</h2>
                <h3 class="mb-1">Variables</h3>
                <p><b>Var:&nbsp;</b>tiene alcance de función, define una variable global o locan en una función din importar el ámbito del bloque.<br><b>Let:&nbsp;</b> tiene alcance de bloque y permite declarar variables limitando su alcance y se puede reasignar<br><b>Const:&nbsp;</b> tiene alcance de constante, se utiliza para declarar una constante que no se puede reasignar.</p>
    
              
                <h3 class="mb-1">Tipos de Datos</h3>
                <p><b>Undefine</b><br>Explicación: El tipo undefined representa una variable que ha sido declarada pero no inicializada.<br> Es el valor predeterminado de las variables que no se les ha asignado un valor.</p>
                <pre><code>
                    let x;
                    console.log(x); // undefined
                </code></pre>
                <p><b>Null</b><br>Explicación:  null es un tipo de dato que representa la ausencia intencionada de un valor. <br>Se utiliza para indicar que una variable no tiene un valor válido. </p>
                <pre><code>
                    let y = null;
                    console.log(y); // null                  
                </code></pre>
                <p><b>Boolean</b><br>Explicacion: El tipo boolean tiene solo dos valores posibles: true(verdadero) y false(falso). <br>Se utiliza para representar valores de verdad.</p>
                <pre><code>
                    let isTrue = true;
                    let isFalse = false;                  
                </code></pre>
                <p><b>Number</b><br>Explicación:  El tipo number representa tanto enteros como números de punto flotante.<br> En JavaScript, todos los números son de tipo number, y no hay distinción entre enteros y decimales.</p>
                <pre><code>
                    let entero = 42;
                    let decimal = 3.14;
                    
                </code></pre>
                <p><b>BinInt</b><br>Explicación: BigIntes un tipo de dato que permite representar números enteros muy grandes que<br> no pueden ser representados por el tipo number. Se utiliza agregando nal final de un número.</p>
                <pre><code>
                    let grande = 1234567890123456789012345678901234567890n;
                </code></pre>
                <p><b>String</b><br>Explicación: El tipo string representa una secuencia de caracteres. Se puede definir utilizando comillas<br> simples, dobles o comillas invertidas (literales de plantilla).</p>
                <pre><code>
                    let texto = "Hola, mundo!";
                </code></pre>
                 <p><b>Simbol</b><br>Explicación:  Symbol es un tipo de dato introducido en ES6 que representa un identificador único e inmutable.<br>Se utiliza principalmente como clave para propiedades de objetos.</p>
                <pre><code>
                    const id = Symbol('id');
                </code></pre>
                <p><b>Object</b><br>Explicación:  El tipo object es una colección de pares clave-valor. Los objetos pueden almacenar datos y funciones<br>(métodos). Es el tipo de dato más complejo en JavaScript.</p>
                <pre><code>
                    let persona = {
                        nombre: "Juan",
                        edad: 30
                    };
                    
                </code></pre>
                <p><b>Array</b><br>Explicación: Aunque los arreglos son técnicamente un tipo de objeto, se consideran de forma separada.<br> Un array es una colección ordenada de elementos, que pueden ser de diferentes tipos. </p>
                <pre><code>
                    let frutas = ["manzana", "banana", "naranja"];
                </code></pre>
          
                <p><b>Typeof</b><br>Explicación:    El operador typeof en JavaScript es una herramienta que se utiliza para determinar el tipo <br>de dato de una variable o de un valor. Es útil para entender qué tipo de datos estás manejando en tu código.<br>Aquí te explico cómo funciona typeof </p>
                <pre><code>
                    let edad = 30;
                    console.log(typeof edad); // "number"
                </code></pre>

               <p>NOTA: Los tipos de datos compuestos son lo que pueden tener multiples datos como Function, Simbol, Array,<br>Object, Date, RegExp y todo los tipos de datos son llamados tipado dinámico</p>
             
                </div>
            </tema-item>
<!-- 3. Básico Operadores -->
            <tema-item>
                <titulo>
                    <strong>3. Básico Operadores</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Operadores Aritmétios</h2>
                <p>Suma (+): Suma dos operandos.</p>
                <pre><code>
                    let suma = 5 + 3; // 8
                </code></pre>
                <p>Resta (-): Resta el segundo operando del primero.</p>
                <pre><code>
                    let resta = 5 - 3; // 2
                </code></pre>
                <p>Multiplicación (*): Multiplica dos operandos.</p>
                <pre><code>
                    let multiplicacion = 5 * 3; // 15
                </code></pre>
                <P>División (/): Divide el primer operando por el segundo.</P>
                <pre><code>
                    let division = 5 / 2; // 2.5
                </code></pre>
                <p>Módulo (%): Retorna el residuo de la división entre dos operandos.</p>
                <pre><code>
                    let modulo = 5 % 2; // 1
                </code></pre>
                <p> Exponenciación (**): Eleva el primer operando a la potencia del segundo.</p>
                <pre><code>
                    let potencia = 2 ** 3; // 8
                </code></pre>
                <h3>Operadores Lógicos</h3>
                <p>Los operadores lógicos se utilizan para combinar expresiones booleanas.</p>
                <p>AND (&&): Retorna true si ambos operandos son verdaderos.</p>
                <pre><code>
                    let and = (true && false); // false
                </code></pre>
                <p>OR (||): Retorna true si al menos uno de los operandos es verdadero.</p>
                <pre><code>
                    let or = (true || false); // true
                </code></pre>
                <p>NOT (!): Invierte el valor de verdad de un operando.</p>
                <pre><code>
                    let not = !true; // false
                </code></pre>
                <h3>Operadores de Comparación</h3>
                <p>Los operadores de comparación se utilizan para comparar dos valores y retornan un valor booleano (true o false).</p>
                <p>gualdad (==): Compara dos valores y retorna true si son iguales, sin considerar el tipo.</p>
                <pre><code>
                    let igual = (5 == '5'); // true
                </code></pre>
                <p>Identidad (===): Compara dos valores y retorna true si son iguales y del mismo tipo.</p>
                <pre><code>
                    let identidad = (5 === '5'); // false
                </code></pre>
                <p>Desigualdad (!=): Compara dos valores y retorna true si no son iguales, sin considerar el tipo.</p>
                <pre><code>
                    let desigual = (5 != '5'); // false
                </code></pre>
                <p>No identidad (!==): Compara dos valores y retorna true si no son iguales o de diferente tipo.</p>
                <pre><code>
                    let noIdentidad = (5 !== '5'); // true
                </code></pre>
                <p>Mayor que (>): Retorna true si el primer operando es mayor que el segundo.</p>
                <pre><code>
                    let mayor = (5 > 3); // true
                </code></pre>
                <p>Menor que (<): Retorna true si el primer operando es menor que el segundo.</p>
                <pre><code>
                    let menor = (5 < 3); // false
                </code></pre>
               <p>Mayor o igual que (>=): Retorna true si el primer operando es mayor o igual que el segundo.</p>
                <pre><code>
                    let mayorIgual = (5 >= 5); // true
                </code></pre>
                <p>Menor o igual que (<=): Retorna true si el primer operando es menor o igual que el segundo.</p>
                <pre><code>
                    let menorIgual = (5 <= 3); // false
                </code></pre>
                <h3>Operadores de asignación</h3>
                <p>Los operadores de asignación se utilizan para asignar valores a variables. El operador de asignación más básico es =.</p>
                <p>Asignación simple (=): Asigna el valor del operando derecho a la variable izquierda.</p>
                <pre><code>
                    let a = 5;
                </code></pre>
                <p>Asignación de suma (+=): Suma el operando derecho al operando izquierdo y asigna el resultado al operando izquierdo.</p>
                <pre><code>
                    a += 3; // a ahora es 8
                </code></pre>
                <p>Asignación de resta (-=): Resta el operando derecho del operando izquierdo y asigna el resultado al operando izquierdo.</p>
                <pre><code>
                    a -= 2; // a ahora es 6
                </code></pre>
                <p>Asignación de multiplicación (*=): Multiplica el operando izquierdo por el derecho y asigna el resultado al operando izquierdo.</p>
                <pre><code>
                    a *= 2; // a ahora es 12
                </code></pre>
                <p>Asignación de división (/=): Divide el operando izquierdo por el derecho y asigna el resultado al operando izquierdo.</p>
                <pre><code>
                    a /= 3; // a ahora es 4
                </code></pre>
                <p>Asignación de módulo (%=): Aplica el operador módulo y asigna el resultado al operando izquierdo.</p>
                <pre><code>
                    a %= 2; // a ahora es 0
                </code></pre>
                <h3>Operadores Ternarios</h3>
                <p>Uso en asignación: El operador ternario también se puede utilizar para asignar valores a variables de manera más compacta:</p>
                <pre><code>
                    let numero = 5;
                let paridad = (numero % 2 === 0) ? "Par" : "Impar";

                console.log(paridad); // "Impar"
                </code></pre>
                <p><b>Anidación de Operadores Ternarios</b><br>Los operadores ternarios se pueden anidar para manejar múltiples condiciones.<br> Sin embargo, es importante usarlos con moderación, ya que pueden hacer que el código sea menos legible.</p>
                <pre><code>
                    let nota = 85;
                let resultado = (nota >= 90) ? "Sobresaliente" :
                (nota >= 75) ? "Notable" :
                (nota >= 60) ? "Aprobado" :
                "Reprobado";

                 console.log(resultado); // "Notable"
                </code></pre>
                </div>
            </tema-item>
<!-- 4.Básico Estructuras de Control.             -->
            <tema-item>
                <titulo>
                    <strong>4. Básico Estructuras de Control</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Estructuras de Control</h2>
                <p>Condicionales<br>Explicación:<br><b>if:</b> Ejecuta un bloque de código si la condición es verdadera.<br><b>if...else:</b>Proporciona una alternativa si la condición es falsa.<br><b>else if:</b> Permite verificar múltiples condiciones.</p>
                <pre><code>
                    if (condición1) {
                        // código si condición1 es verdadera
                    } else if (condición2) {
                        // código si condición2 es verdadera
                    } else {
                        // código si ninguna condición es verdadera
                    }
                    
                </code></pre>

                <p><b>Switch</b><br>Explicación: Selecciona uno de varios bloques de código a ejecutar, basado en el valor de una expresión.</p>    
                <pre><code>
                switch (expresión) {
                    case valor1:
                        // código si expresión es igual a valor1
                        break;
                    case valor2:
                        // código si expresión es igual a valor2
                        break;
                    default:
                        // código si ninguna de las condiciones anteriores es verdadera
                }
                
                </code></pre>
                <p><b>For</b><br>Explicación: Ejecuta un bloque de código un número específico de veces.</p>
                <pre><code>
                for (inicialización; condición; incremento) {
                    // código a ejecutar
                }
                //Otro ejemplo
                for (let i = 0; i < 5; i++) {
                    console.log(i);
                }
                </code></pre>
                <p><b>While</b><br>Explicación: Ejecuta un bloque de código mientras la condición sea verdadera.</p>
                <pre><code>
                while (condición) {
                    // código a ejecutar
                }
                //otro ejemplo   
                let contador = 0;

                while (contador < 5) {
                console.log("Contador:", contador);
                contador++; // Incrementa el contador
                }
                </code></pre>
                <p><b>Do while</b><br>Explicación: Similar a while, pero garantiza que el bloque de código se ejecutará al menos una vez</p>
                <pre><code>
                do {
                    // código a ejecutar
                } while (condición);
                
                // otro ejemplo
                let contador = 0;

                do {
                console.log("Contador:", contador);
                contador++; // Incrementa el contador
                } while (contador < 5);


                </code></pre>
                <p><b>break:</b> Termina el bucle o el bloque switchactual.<br><b>continue:</b> Salta la iteración actual del bucle y pasa a la siguiente.</p>
                <p><b>Try Catch</b><br>Explicación: Maneja excepciones que pueden ocurrir en el código.<br><b>Try:</b>La instrucción try se utiliza para envolver el código que puede generar un error.<br>Si se produce un error dentro del bloque try, el control se transfiere al bloque catch.<br><b>Catch:</b> El bloque catch se ejecuta si se produce un error en el bloque try.<br>Puedes acceder al objeto de error que se generó para obtener más información sobre el problema.<br><b>El bloque finally</b> se ejecuta después de los bloques try y catch, independientemente de si se lanzó un error o no.<br>Es útil para realizar tareas de limpieza, como cerrar conexiones o liberar recursos.</p>   

                <pre><code>
                 try {
                    // código que puede causar un error
                } catch (error) {
                    // código que maneja el error
                } finally {
                    // código que se ejecuta siempre, sin importar si hubo error o no
                }
                
                function dividir(a, b) {
                    try {
                        if (b === 0) {
                            throw new Error("No se puede dividir por cero"); // Lanzar un error personalizado
                        }
                        let resultado = a / b;
                        console.log("Resultado:", resultado);
                    } catch (error) {
                        console.error("Error:", error.message);
                    } finally {
                        console.log("Operación de división completada.");
                    }
                }
                
                // Llamadas a la función
                dividir(10, 2); // Resultado: 5
                dividir(10, 0); // Error: No se puede dividir por cero
                </code></pre>
                </div>
            </tema-item>
<!-- 5.Funciones Básicas -->
            <tema-item>
                <titulo>
                    <strong>5. Básico Funciones</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h3 class="mb-1">Funciones</h3>
                <p><b>Funciones Declaradas.</b><br>Explicación:&nbsp;Son funciones definidas con la palabra clave functiony tienen un nombre.<br> Se pueden llamar antes de ser declaradas debido al levantamiento.</p>
                <pre><code>
                    function saludar() {
                        console.log("Hola!");
                    }
                </code></pre>
                <p><b>Funciones Expresadas</b><br>Explicación:&nbsp;Son funciones que se definen como parte de una expresión, y pueden ser anónimas (sin nombre)<br> o nombradas. No se pueden llamar antes de su declaración.</p>
                <pre><code>
                    const despedir = function() {
                        console.log("Adiós!");
                    }; 
                </code></pre>
                <p><b>Funciones Flecha.</b><br>Explicación:&nbsp;Introducidas en ES6, las funciones flecha son una forma más concisa de escribir funciones.<br>No tienen su propio contexto this.</p>
                <pre><code>
                    const multiplicar = (a, b) => a * b;
                </code></pre>
                <p><b>Funciones Flecha de una sola expresión.</b><br>Explicación:&nbsp;Estas funciones utilizan una sintaxis simplificada. Si la función consiste en una sola expresión,<br> no es necesario usar llaves {}ni la palabra clave return. El resultado de la expresión se devuelve automáticamente.</p>
                <pre><code>
                    const sumar = (a, b) => a + b;
                    console.log(sumar(5, 3)); // 8
                    
                </code></pre>
                <p><b>Funciones Flecha de Múltiples Líneas</b><br>Explicación:&nbsp;Si la función tiene más de una expresión o se necesita realizar múltiples acciones, se deben usar llaves {}<br>y la declaración returnpara devolver un valor.</p>
                <pre><code>
                    const saludar = (nombre) => {
                        const saludo = `Hola, ${nombre}!`;
                        return saludo;
                    };
                    
                    console.log(saludar("Juan")); // "Hola, Juan!"
                    
                </code></pre>
                <p><b>Funciones Flecha con Fetch</b><br>Explicación:&nbsp;El método fetchse utiliza para hacer solicitudes de red y devuelve una promesa. Aquí hay un ejemplo<br> que muestra cómo hacer una solicitud GET a una API y procesar la respuesta usando una función flecha:.</p>
                <pre><code>
                    // Función flecha para obtener datos de una API
                    const obtenerDatos = () => {
                        fetch('https://jsonplaceholder.typicode.com/posts')
                            .then(respuesta => {
                                if (!respuesta.ok) {
                                    throw new Error('Error en la respuesta de la red');
                                }
                                return respuesta.json(); // Convierte la respuesta a JSON
                            })
                            .then(datos => {
                                console.log(datos); // Muestra los datos en la consola
                            })
                            .catch(error => {
                                console.error('Hubo un problema con la solicitud:', error);
                            });
                    };
                    
                    // Llamar a la función
                    obtenerDatos();
                          
                </code></pre>
                <p><b>Funciones Flecha con async y await</b><br>Explicación:&nbsp;En este ejemplo, realizaremos una solicitud a una API utilizando fetchy manejaremos la respuesta asíncrona con asyncy await.</p>
                <pre><code>
                    // Función flecha asíncrona para obtener datos de una API
                    const obtenerDatos = async () => {
                        try {
                            const respuesta = await fetch('https://jsonplaceholder.typicode.com/posts');
                            
                            if (!respuesta.ok) {
                                throw new Error('Error en la respuesta de la red');
                            }
                            
                            const datos = await respuesta.json(); // Convierte la respuesta a JSON
                            console.log(datos); // Muestra los datos en la consola
                        } catch (error) {
                            console.error('Hubo un problema con la solicitud:', error);
                        }
                    };
                    
                    // Llamar a la función
                    obtenerDatos();
                    
                </code></pre>
                <p><b>Funciones Anónimas.</b><br>Explicación:&nbsp;Son funciones sin nombre, utilizadas como argumentos de otras funciones o en expresiones.</p>
                <pre><code>
                    setTimeout(function() {
                        console.log("Ejecutado después de 2 segundos");
                    }, 2000);       
                </code></pre>
                <p><b>Funciones de devolución de llamada</b><br>Explicación:&nbsp;Son funciones que se pasan como argumentos a otras funciones y se ejecutan en respuesta<br> a un evento o después de que se completa una tarea.</p>
                <pre><code>
                    function procesarDatos(callback) {
                        // Simular procesamiento
                        callback();
                    }
                    
                    procesarDatos(() => console.log("Datos procesados"));                    
                </code></pre>
                <p><b>Funciones Constructoras</b><br>Explicación:&nbsp;Son funciones que se utilizan para crear objetos. Se invocan con la palabra clave new</p>
                <pre><code>
                        function Persona(nombre) {
                            this.nombre = nombre;
                        }
                        
                        const juan = new Persona("Juan");
                        
                </code></pre>
                <p><b>Funciones Recursivas</b><br>Explicación:&nbsp;Son funciones que se llaman a sí mismas para resolver un problema.</p>
                <pre><code>
                        function factorial(n) {
                            if (n === 0) return 1;
                            return n * factorial(n - 1);
                        }       
                </code></pre>
                <p></p>
                <pre><code>
                </code></pre>
                </div>
            </tema-item>
<!-- 6. Matrices y Objetos básicos -->
            <tema-item>
                <titulo>
                    <strong>6. Básico Matrices y Objeto.</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Matrices y Objetos Básicos.</h2>
                <p>1. Crear y manipular matrices en JavaScript</p>
                <pre><code>
                    let frutas = ['manzana', 'banana', 'naranja'];
                </code></pre>


                <table class="table">
                    <thead>
                        <tr>
                            <th>Método</th>
                            <th>Función</th>
                            <th>Ejemplo</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>.push()</td>
                            <td>Añade uno o más elementos al final de la matriz</td>
                            <td>frutas.push('pera'); // ['manzana', 'banana', 'naranja', 'pera']</td>
                        </tr>
                        <tr>
                            <td>.pop()</td>
                            <td>Elimina y devuelve el último elemento de la matriz</td>
                            <td>let ultimaFruta = frutas.pop(); // 'pera' y matriz sin 'pera'</td>
                        </tr>
                        <tr>
                            <td>.shift()</td>
                            <td>Elimina y devuelve el primer elemento</td>
                            <td>et primerFruta = frutas.shift(); // 'manzana' y matriz sin 'manzana'</td>
                        </tr>
                        <tr>
                            <td>.unshift()</td>
                            <td>Añade uno o más elementos al inicio</td>
                            <td>frutas.unshift('fresa'); // ['fresa', 'banana', 'naranja']</td>
                        </tr>
                        <tr>
                            <td>.splice()</td>
                            <td>Elimina, reemplaza o añade elementos en la matriz</td>
                            <td>frutas.splice(1, 1, 'limón'); // en índice 1 elimina 'banana' y añade 'limón'</td>
                        </tr>
                        <tr>
                            <td>.slice()</td>
                            <td>Extrae una copia de una parte de la matriz</td>
                            <td>let algunasFrutas = frutas.slice(1, 3); // copia elementos en índice 1 y 2</td>
                        </tr>
                    </tbody>
                </table>
                <p>2. Ejemplo práctico con todos los métodos</p>
                <pre><code>
                    let colores = ['rojo', 'azul', 'verde'];

                // push
                colores.push('amarillo'); // ['rojo', 'azul', 'verde', 'amarillo']

                // pop
                let ultimoColor = colores.pop(); // 'amarillo', matriz ahora ['rojo', 'azul', 'verde']

                // unshift
                colores.unshift('negro'); // ['negro', 'rojo', 'azul', 'verde']

                // shift
                let primerColor = colores.shift(); // 'negro', matriz ahora ['rojo', 'azul', 'verde']

                // splice: reemplazar 'azul' por 'celeste'
                colores.splice(1, 1, 'celeste'); // ['rojo', 'celeste', 'verde']

                // slice: obtener una copia de los primeros dos colores
                let primerosColores = colores.slice(0, 2); // ['rojo', 'celeste']

                </code></pre>
                <p>3. Crear objetos con propiedades y métodos</p>
                <pre><code>
                    let persona = {
                        nombre: 'Juan',
                        edad: 30,
                      
                        saludar: function() {
                          console.log('Hola, mi nombre es ' + this.nombre);
                        }
                      };
                      
                      // Uso del método
                      persona.saludar(); // 'Hola, mi nombre es Juan'

                      persona.direccion = 'Calle 123';

                      persona.saludarConEdad = function() {
                      console.log('Hola, ' + this.nombre + '. Tienes ' + this.edad + ' años.');
                    };

                    persona.saludarConEdad(); // 'Hola, Juan. Tienes 30 años.'
      
                </code></pre>

                <p>Ejemplo completo: Gestión de una librería</p>
                <pre><code>
                    // Crear una matriz de libros (cada libro es un objeto)
                let libreria = [
                 { titulo: 'Cien Años de Soledad', autor: 'Gabriel García Márquez' },
                 { titulo: 'El Principito', autor: 'Antoine de Saint-Exupéry' },
                 { titulo: 'Don Quijote', autor: 'Miguel de Cervantes' }
                ];

                // Función para mostrar todos los libros
                function mostrarLibros() {
                 console.log('Libros en la librería:');
                 libreria.forEach((libro, index) => {
                 console.log(`${index + 1}. "${libro.titulo}" por ${libro.autor}`);
                 });
                }

                // Agregar un nuevo libro al final (push)
                libreria.push({ titulo: 'La sombra del viento', autor: 'Carlos Ruiz Zafón' });
                mostrarLibros();

                // Eliminar el último libro (pop)
                let libroEliminado = libreria.pop();
                console.log('Libro eliminado:', libroEliminado.titulo);
                mostrarLibros();

                // Agregar un libro al inicio (unshift)
                libreria.unshift({ titulo: '1984', autor: 'George Orwell' });
                mostrarLibros();

                // Eliminar el primer libro (shift)
                let primerLibro = libreria.shift();
                console.log('Primer libro eliminado:', primerLibro.titulo);
                mostrarLibros();

                // Reemplazar un libro en una posición específica (splice)
                libreria.splice(1, 1, { titulo: 'Fahrenheit 451', autor: 'Ray Bradbury' });
                mostrarLibros();

                // Extraer algunos libros (slice)
                let algunosLibros = libreria.slice(0, 2);
                console.log('Algunos libros seleccionados:');
                algunosLibros.forEach(libro => {
                console.log(`- "${libro.titulo}" por ${libro.autor}`);
                });

               // Crear un objeto `biblioteca` con métodos para gestionar los libros
               let biblioteca = {
               libros: libreria,

               agregarLibro: function(titulo, autor) {
               this.libros.push({ titulo, autor });
               },

               eliminarLibro: function(titulo) {
               this.libros = this.libros.filter(libro => libro.titulo !== titulo);
               },

               mostrarLibros: function() {
               console.log('Libros en la biblioteca:');
               this.libros.forEach((libro, index) => {
               console.log(`${index + 1}. "${libro.titulo}" por ${libro.autor}`);
               }); 
             }
            };

               // Usando los métodos del objeto `biblioteca`
               biblioteca.agregarLibro('El Hobbit', 'J.R.R. Tolkien');
               biblioteca.mostrarLibros();

               biblioteca.eliminarLibro('1984');
               biblioteca.mostrarLibros();

                </code></pre>
                </div>
            </tema-item>
<!-- 7.DOM Básico -->
            <tema-item>
                <titulo>
                    <strong>7. DOM Básico</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>DOM Básico.</h2>
                <p>1. Selección de elementos del DOM <br>getElementById: Permite seleccionar un elemento HTML por su atributo id.</p>
                <pre><code>
                    <div id="miDiv">Hola Mundo</div>

                    let div = document.getElementById('miDiv');
                    console.log(div.textContent); // "Hola Mundo"
                </code></pre>
                <p>querySelector: Permite seleccionar el primer elemento que coincida con un selector CSS (clases, etiquetas, atributos, etc.).</p>
                <pre><code>
                    <p class="parrafo">Este es un párrafo</p>

                    let parrafo = document.querySelector('.parrafo');
                    console.log(parrafo.textContent); // "Este es un párrafo"
                    
                    let btn = document.querySelector('button#miBoton');
                </code></pre>
                <p>2. Manipulación de textos y atributos<br>Cambiar el contenido de un elemento</p>
                <pre><code>
                    let titulo = document.getElementById('titulo');
                    titulo.textContent = 'Nuevo Título'; // cambia solo el texto
                    titulo.innerHTML = '<strong>Nuevo Título en negrita</strong>'; // cambia el contenido HTML
                </code></pre>
                <p>Manipular atributos</p>
                <pre><code>
                    let enlace = document.querySelector('a'); // supongamos que hay un enlace
                    enlace.setAttribute('href', 'https://www.ejemplo.com'); // cambia o establece el atributo href
                    console.log(enlace.getAttribute('href')); // obtiene el valor del atributo
                    enlace.removeAttribute('href'); // elimina el atributo
                </code></pre>
                <p>3. Eventos: onclick y addEventListener<br>onclick (Directamente en HTML o JavaScript)</p>
                <pre><code>
                    <button id="miBoton">Haz clic</button>

                    let boton = document.getElementById('miBoton');

                    boton.onclick = function() {
                     alert('¡Has hecho clic en el botón!');
                    };
                </code></pre>
                <p>addEventListener (más flexible y recomendable)<br>Permite agregar múltiples manejadores de evento y es más limpio.</p>
                <pre><code>
                    let boton = document.getElementById('miBoton');

                    boton.addEventListener('click', function() {
                    alert('¡Evento con addEventListener!');
                });
                //También puedes escuchar otros eventos:
                // Evento al pasar el mouse
                boton.addEventListener('mouseover', function() {
                console.log('El mouse está sobre el botón');
                });
                </code></pre>
                <p>Ejemplo práctico.</p>
                <pre><code>
                    <body>
                    
                    //Código JavaScript para manipular elementos del DOM
                    
                    <!-- Aquí mostramos el código como texto formateado -->
                    <pre><code>
                    &lt;script&gt;
                      // Selección de elementos
                      const titulo = document.getElementById('titulo');
                      const parrafo = document.querySelector('.parrafo');
                      const enlace = document.querySelector('#enlace');
                      const boton = document.getElementById('miBoton');
                    
                      // Manipulación de texto
                      titulo.textContent = 'Título modificado con JavaScript';
                      parrafo.innerHTML = 'Este párrafo tiene &lt;strong&gt;texto en negrita&lt;/strong&gt;';
                    
                      // Manipulación de atributos
                      enlace.setAttribute('href', 'https://www.openai.com');
                      console.log('Href del enlace:', enlace.getAttribute('href'));
                    
                      // Eventos
                      boton.addEventListener('click', function() {
                        alert('¡Has hecho clic en el botón!');
                        // Cambiar el texto del título
                        titulo.textContent = 'Título cambiado tras clic';
                      });
                    &lt;/script&gt;
                    </code></pre>
                    
                    <!-- Aquí tienes el código HTML original para que puedas copiar y pegar -->
                    //Código HTML completo (para copiar y usar)
                    <pre><code>
                    &lt;!DOCTYPE html&gt;
                    &lt;html lang="es"&gt;
                    &lt;head&gt;
                    &lt;meta charset="UTF-8" /&gt;
                    &lt;title&gt;Ejemplo DOM&lt;/title&gt;
                    &lt;/head&gt;
                    &lt;body&gt;
                    
                    &lt;h1 id="titulo"&gt;Título original&lt;/h1&gt;
                    &lt;p class="parrafo"&gt;Texto del párrafo&lt;/p&gt;
                    &lt;a id="enlace" href="#"&gt;Enlace&lt;/a&gt;
                    &lt;br&gt;&lt;br&gt;
                    &lt;button id="miBoton"&gt;Haz clic en mí&lt;/button&gt;
                    
                    &lt;script&gt;
                      // Selección de elementos
                      const titulo = document.getElementById('titulo');
                      const parrafo = document.querySelector('.parrafo');
                      const enlace = document.querySelector('#enlace');
                      const boton = document.getElementById('miBoton');
                    
                      // Manipulación de texto
                      titulo.textContent = 'Título modificado con JavaScript';
                      parrafo.innerHTML = 'Este párrafo tiene &lt;strong&gt;texto en negrita&lt;/strong&gt;';
                    
                      // Manipulación de atributos
                      enlace.setAttribute('href', 'https://www.openai.com');
                      console.log('Href del enlace:', enlace.getAttribute('href'));
                    
                      // Eventos
                      boton.addEventListener('click', function() {
                        alert('¡Has hecho clic en el botón!');
                        // Cambiar el texto del título
                        titulo.textContent = 'Título cambiado tras clic';
                      });
                    &lt;/script&gt;
                    
                    &lt;/body&gt;
                    &lt;/html&gt;
                    </code></pre>
                    
                    </body>
                    </html> 
                </code></pre>
                </div>
            </tema-item>
<!-- 8.Intermedio-Funciones Avanzadas -->
            <tema-item>
                <titulo>
                    <strong>8.Intermedio-Funciones Avanzadas.</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Funciones Avanzadas.</h2>
                <p><b>1. Funciones como objetos de primera clase</b></p>
                <p>En JavaScript, las funciones son ciertamente objetos de primera clase, lo que significa que:<br>Pueden ser almacenadas en variables.<br>Pasadas como argumentos a otras funciones.<br>Devueltas como valores desde funciones.<br>Tener propiedades y métodos propios.</p>
                <pre><code>
                    // Función asignada a una variable
                const saludar = function(nombre) {
                return 'Hola, ' + nombre;
                };

                // Usar la función
                console.log(saludar('Ana')); // "Hola, Ana"

                // Función con propiedades
                saludar.contador = 0;

                const saludarConContador = function(nombre) {
                saludar.contador++;
                return 'Hola, ' + nombre + '! Esta es la vez número ' + saludar.contador;
                };

                console.log(saludarConContador('Juan')); // "Hola, Juan! Esta es la vez número 1"
                console.log(saludarConContador('Pedro')); // "Hola, Pedro! Esta es la vez número 2"
                </code></pre>
                <p><b>2.Callbacks (Funciones de devolución de llamada)</b><br>Una función callback es una función que se pasa como argumento a otra función y que será ejecutada en algún momento dentro de esa función.</p>
                <pre><code>
                    function procesarNumero(numero, callback) {
                        let resultado = callback(numero);
                        console.log('Resultado:', resultado);
                      }
                      
                      procesarNumero(5, function(n) {
                        return n * n; // devuelve el cuadrado
                      }); // Resultado: 25
                      
                      // También con funciones nombradas
                      function doble(n) {
                        return n * 2;
                      }
                      procesarNumero(10, doble); // Resultado: 20                      
                </code></pre>

                <p><b>3. Clousures (Clausuras)</b><br>Una clausura es una función que "recuerda" el entorno en el que fue creada, es decir, puede acceder a variables externas incluso después de que esa función se ha ejecutado.</p>
                <pre><code>
                    function crearContador() {
                        let contador = 0; // variable externa a la función interna
                        
                        return function() {
                          contador++;
                          return contador;
                        };
                      }
                      
                      const contador1 = crearContador();
                      console.log(contador1()); // 1
                      console.log(contador1()); // 2
                      
                      const contador2 = crearContador();
                      console.log(contador2()); // 1
                      console.log(contador2()); // 2
                      
                </code></pre>
                <p><b>4.IIFE (Immediately Invoked Function Expression) — Funciones autoejecutables.</b><br>Una IIFE es una función que se define y se ejecuta inmediatamente. Se usa para crear un ámbito aislado y evitar colisiones de variables en el código global.</p>
                <pre><code>
                    (function() {
                        // código aquí
                      })();

                      (function() {
                        const mensaje = 'Hola desde la IIFE';
                        console.log(mensaje);
                      })();
                      
                      // La variable mensaje no existe fuera de la IIFE
                      // console.log(mensaje); // Error: mensaje no definido
                      
                      (() => {
                        console.log('Soy una función flecha autoejecutable');
                      })();
                          
                </code></pre>
                </div>
            </tema-item>
<!-- 9.Intermedio-Objetos y prototipos             -->
            <tema-item>
                <titulo>
                    <strong>9.Intermedio-Objetos y prototipos.</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Objetos y prototipos.</h2>
                <p><b> Objetos en JavaScript</b><br>Un objeto es una colección de propiedades y métodos.</p>
                <pre><code> 
                    const persona = {
                        nombre: 'Juan',
                        edad: 30,
                        saludar: function() {
                          console.log('Hola, ' + this.nombre);
                        }
                      };
                      persona.saludar(); // Hola, Juan                      
                </code></pre>
                <p><b>2. Funciones constructoras y creación de objetos.</b><br>Las funciones constructoras sirven para crear objetos similares.</p>
                <pre><code>  
                    function Persona(nombre, edad) {
                        this.nombre = nombre;
                        this.edad = edad;
                        this.saludar = function() {
                          console.log('Hola, soy ' + this.nombre);
                        };
                      }
                      
                      const p1 = new Persona('Ana', 25);
                      p1.saludar(); // Hola, soy Ana                      
                </code></pre>
                 <p><b>3. Prototipo y herencia prototípica</b><br>Cada función tiene un prototipo (una propiedad llamada prototype) donde se pueden definir métodos y propiedades compartidas</p>
                <pre><code>  
                    function Persona(nombre, edad) {
                        this.nombre = nombre;
                        this.edad = edad;
                      }
                      
                      // Agregar método al prototipo
                      Persona.prototype.saludar = function() {
                        console.log('Hola, ' + this.nombre);
                      };
                      
                      const p2 = new Persona('Luis', 40);
                      p2.saludar(); // Hola, Luis                      
                </code></pre>
                <p><b>Herencia prototípica:</b><br>Creamos una "subclase" que hereda del prototipo de otra:</p>
                <pre><code> 
                    function Estudiante(nombre, edad, escuela) {
                        Persona.call(this, nombre, edad); // Hereda propiedades
                        this.escuela = escuela;
                      }
                      
                      // La herencia: asignar el prototipo de Estudiante al de Persona
                      Estudiante.prototype = Object.create(Persona.prototype);
                      Estudiante.prototype.constructor = Estudiante;
                      
                      // Agregar método específico
                      Estudiante.prototype.estudiar = function() {
                        console.log(this.nombre + ' está estudiando en ' + this.escuela);
                      };
                      
                      const alumno = new Estudiante('Carlos', 20, 'MIT');
                      alumno.saludar(); // Hola, Carlos
                      alumno.estudiar(); // Carlos está estudiando en MIT
                       
                </code></pre>
                <p><b>4. Uso de this, call, apply, y bind</b></p>
                <p>this</p>
                <pre><code> 
                    const persona = {
                        nombre: 'Ana',
                        hablar: function() {
                          console.log('Hola, ' + this.nombre);
                        }
                      };
                      persona.hablar(); // Hola, Ana                      
                </code></pre>
                <p>call()</p>
                <pre><code>
                    function mostrar() {
                        console.log('Mi nombre es ' + this.nombre);
                      }
                      
                      const persona1 = { nombre: 'Luis' };
                      const persona2 = { nombre: 'Laura' };
                      
                      mostrar.call(persona1); // Mi nombre es Luis
                      mostrar.call(persona2); // Mi nombre es Laura                        
                </code></pre>
                <p>apply()<br>Similar a call(), pero recibe los argumentos en forma de array.</p>
                <pre><code>
                    mostrar.apply(persona1); // Mi nombre es Luis  
                </code></pre>
                <p>bind()</p>
                <pre><code> 
                    const hablarLuis = mostrar.bind(persona1);
                    hablarLuis(); // Mi nombre es Luis
                </code></pre>
            </div>
            </tema-item>
<!-- 10.Arrays y objetos avanzados  -->
            <tema-item>
                <titulo>
                    <strong>10.Intermedio-Arrays y Objetos.</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Arrays y Objetos.</h2>
                <p><b>1. Arrays avanzados</b></p>
                <p>a) forEach(): Itera sobre cada elemento del array, sin devolver un nuevo array.</p>
                <pre><code> 
                    const numeros = [1, 2, 3, 4];
                    numeros.forEach(n => console.log(n * 2));
                    // Salida: 2, 4, 6, 8
                </code></pre>
                <p>b) map(): Crea un nuevo array transformando cada elemento.</p>
                <pre><code> 
                    const cuadrados = numeros.map(n => n * n);
                    console.log(cuadrados); // [1, 4, 9, 16]
                </code></pre>
                <p>c) filter(): Filtra los elementos que cumplen una condición y devuelve un nuevo array.</p>
                <pre><code> 
                    const pares = numeros.filter(n => n % 2 === 0);
                    console.log(pares); // [2, 4]
                </code></pre>
                <p>d) reduce(): Reduce un array a un único valor, acumulando los resultados.</p>
                <pre><code> 
                    const sumaTotal = numeros.reduce((acum, n) => acum + n, 0);
                    console.log(sumaTotal); // 10
                </code></pre>
                <p>e) find(): Busca y devuelve el primer elemento que cumple una condición.</p>
                <pre><code>
                    const busqueda = numeros.find(n => n > 2);
                    console.log(busqueda); // 3
                </code></pre>
                <p>f) some(): Verifica si al menos un elemento cumple una condición (devuelve true o false).</p>
                <pre><code> 
                    const hayPares = numeros.some(n => n % 2 === 0);
                    console.log(hayPares); // true
                </code></pre>
                <p>g) every(): Verifica si todos los elementos cumplen una condición.</p>
                <pre><code> 
                    const todosPositivos = numeros.every(n => n > 0);
                    console.log(todosPositivos); // true
                </code></pre>
                <p><b>2. Objetos avanzados y desestructuración</b></p>
                <p>a) Desestructuración de objetos<br>Extraer propiedades fácilmente:</p>
                <pre><code> 
                    const persona = { nombre: 'Juan', edad: 30, ciudad: 'Madrid' };
                    const { nombre, edad } = persona;
                    console.log(nombre); // Juan
                    console.log(edad);   // 30
                </code></pre>
                <p>b) Desestructuración en arrays</p>
                <pre><code>
                    const colores = ['rojo', 'azul', 'verde'];
                    const [color1, color2, color3] = colores;
                    console.log(color2); // azul
                </code></pre>
                <p>3. Operador spread (...) y operador rest (...)</p>
                <p>a) Spread en arrays y objetos<br>En arrays:</p>
                <pre><code>
                    const nums1 = [1, 2, 3];
                    const nums2 = [4, 5, 6];
                    const todos = [...nums1, ...nums2]; // [1, 2, 3, 4, 5, 6]
                </code></pre>
                <p>En objetos:</p>
                <pre><code>
                    const persona1 = { nombre: 'Ana', edad: 25 };
                    const persona2 = { ...persona1, ciudad: 'Sevilla' };
                    console.log(persona2); // { nombre: 'Ana', edad: 25, ciudad: 'Sevilla' }
                </code></pre>
                <p>b) Rest en funciones:<br>Permite recibir un número variable de argumentos:</p>
                <pre><code>
                    function sumar(...numeros) {
                        return numeros.reduce((acum, n) => acum + n, 0);
                      }
                      
                      console.log(sumar(1, 2, 3, 4)); // 10
                      
                </code></pre>
                <p>Resumen</p>
                <pre><code>
                    const productos = [
                 { id: 1, nombre: 'Lapiz', precio: 1.5 },
                 { id: 2, nombre: 'Cuaderno', precio: 3 },
                 { id: 3, nombre: 'Borrador', precio: 0.5 },
                 { id: 4, nombre: 'Goma', precio: 0.7 }
                ];

                // map: lista de nombres
                const nombres = productos.map(p => p.nombre);
                console.log(nombres); // ['Lapiz', 'Cuaderno', 'Borrador', 'Goma']

                // filter: productos con precio > 1
                const caros = productos.filter(p => p.precio > 1);
                console.log(caros);

                // reduce: suma total de precios
               const total = productos.reduce((acum, p) => acum + p.precio, 0);
               console.log(total);

              // find: producto con id 2
             const productoEncontrado = productos.find(p => p.id === 2);
             console.log(productoEncontrado);

             // some: hay productos con precio menor a 0.6
             const barato = productos.some(p => p.precio < 0.6);
             console.log(barato); // true

            // every: todos tienen precio mayor a 0.4
            const todosCaros = productos.every(p => p.precio > 0.4);
            console.log(todosCaros); // true

            // Desestructuración
            const { nombre } = productoEncontrado;
            console.log(nombre); // Cuaderno

            // Spread y Rest
           const copiaProductos = [...productos]; // copia del array
           function imprimirProductos(...productos) {
           productos.forEach(p => console.log(p.nombre));
           }
           imprimirProductos(...productos);
                </code></pre>
                </div>
            </tema-item>
<!-- 11.ES6+(JavaScript moderno) -->
            <tema-item>
                <titulo>
                    <strong>11.Intemedio ES6 + Javascript Moderno</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Javascript Moderno</h2>
                <p><b>Let y Conts</b><br>let: declara variables que pueden cambiar su valor.<br>const: declara variables que no cambian (constantes).</p>
                <pre><code>
                    let nombre = "Rodolfo";
                        nombre = "Pedro"; // OK

                    const edad = 30;
                        edad = 31; // ❌ Error
                </code></pre>
                <p><b>Plantillas literales (Template Literals)</b><br>Permiten insertar variables fácilmente dentro de cadenas usando backticks ` y ${}:</p>
                <pre><code>
                    const nombre = "Rodolfo";
                    const saludo = `Hola, mi nombre es ${nombre}`;
                    console.log(saludo); // "Hola, mi nombre es Rodolfo"
                </code></pre>
                <p><b>Funciones de Flecha (Arrow Funtions)</b><br>Una forma más corta de declarar funciones:</p>
                <pre><code>
                    // Tradicional
                    function sumar(a, b) {
                    return a + b;
                    }

                    // Arrow function
                    const sumar = (a, b) => a + b;
                    <p>Nota: No tienen su propio this, lo cual las hace útiles para callbacks o métodos donde no quieres cambiar el contexto.</p>
                </code></pre>
                <p><b>Módulos (importación/exportación)</b><br>Permiten dividir el código en archivos reutilizables.<br>Archivo saludos.js:</p>
                <pre><code>
                    export const saludar = (nombre) => `Hola, ${nombre}`;
                </code></pre>
                <pre><code>
                    <p>Archivo app.js</p>

                    import { saludar } from './saludos.js';
                    console.log(saludar("Rodolfo"));

                   <p>También puedes usar export default para exportar una sola cosa sin nombre fijo.</p>
                </code></pre>
                <p><b>Clases (class, extends, super)</b><br>Sintaxis orientada a objetos moderna:</p>
                <pre><code>
                    class Animal {
                        constructor(nombre) {
                          this.nombre = nombre;
                        }
                        hablar() {
                          console.log(`${this.nombre} hace un ruido`);
                        }
                      }
                      
                      class Perro extends Animal {
                        hablar() {
                          super.hablar(); // llama a método del padre
                          console.log(`${this.nombre} ladra`);
                        }
                      }
                      
                      const miPerro = new Perro("Firulais");
                      miPerro.hablar();
                      
                </code></pre>
                <p><b>Promesas (Promise, .then, .catch)</b><br>Sirven para manejar operaciones asíncronas (como peticiones HTTP).</p>
                <pre><code>
                    const obtenerDatos = () => {
                        return new Promise((resolve, reject) => {
                          setTimeout(() => {
                            const exito = true;
                            if (exito) {
                              resolve("Datos obtenidos");
                            } else {
                              reject("Error al obtener datos");
                            }
                          }, 1000);
                        });
                      };
                      
                      obtenerDatos()
                        .then((resultado) => console.log(resultado))
                        .catch((error) => console.error(error));

                        <p>También puedes usar async/await para simplificar el código.</p>
                </code></pre>
                
            </div>
            </tema-item>
<!-- 12.Asincronia             -->
            <tema-item>
                <titulo>
                    <strong>12.Intermedio-Asincronia</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                <h2>Asincronia</h2>
                <p><b>¿Qué es la asincronía?</b><br>avaScript es monohilo (un solo hilo de ejecución). Pero con asincronía puede realizar tareas que toman tiempo (como leer archivos, hacer peticiones a APIs, etc.) sin bloquear el hilo principal.</p>
                <p><b>Promesas encadenadas (Chained Promises)</b><br>Las promesas (Promise) permiten manejar operaciones que se completan más adelante.</p>
                <pre><code>
                    function pasoUno() {
                        return new Promise((resolve) => {
                          setTimeout(() => {
                            console.log("Paso 1 completo");
                            resolve("Resultado del paso 1");
                          }, 1000);
                        });
                      }
                      
                      function pasoDos(datoAnterior) {
                        return new Promise((resolve) => {
                          setTimeout(() => {
                            console.log("Paso 2 usando:", datoAnterior);
                            resolve("Resultado del paso 2");
                          }, 1000);
                        });
                      }
                      
                      pasoUno()
                        .then((resultado1) => pasoDos(resultado1))
                        .then((resultado2) => {
                          console.log("Todo completo:", resultado2);
                        })
                        .catch((error) => {
                          console.error("Error en la cadena:", error);
                        });

                        <p> Aquí encadenamos .then() para pasar los resultados de una promesa a la siguiente.</p>
                </code></pre>
                <p><b>async / await: sintaxis más limpia</b>Con async/await, puedes escribir código asíncrono como si fuera síncrono:</p>
                <pre><code>
                    async function proceso() {
                        try {
                          const resultado1 = await pasoUno();
                          const resultado2 = await pasoDos(resultado1);
                          console.log("Proceso finalizado:", resultado2);
                        } catch (error) {
                          console.error("Error en proceso async:", error);
                        }
                      }
                      
                      proceso();
                      
                      <p>Ventajas de async/await:<br>Más fácil de leer<br>Menos .then() anidados<br>Manejo de errores con try/catch</p>
                </code></pre>
                <p><b>Manejo de errores asíncronos</b></p>Con promesas:</p>
                <pre><code>
                    fetch("https://jsonplaceholder.typicode.com/posts/12345")
                    .then((res) => {
                    if (!res.ok) throw new Error("No se pudo obtener el recurso");
                    return res.json();
                    })
                    .then((data) => console.log(data))
                    .catch((err) => console.error("Error:", err.message));
                </code></pre>
                <p>Con async/await:</p>
                <pre><code>
                    async function obtenerPost() {
                        try {
                          const res = await fetch("https://jsonplaceholder.typicode.com/posts/12345");
                          if (!res.ok) throw new Error("No se pudo obtener el recurso");
                          const data = await res.json();
                          console.log(data);
                        } catch (err) {
                          console.error("Error async/await:", err.message);
                        }
                      }
                      
                      obtenerPost();     
                </code></pre>
                <table border="2">
                    <thead>
                      <tr>
                        <th>Técnica</th>
                        <th>Ventajas</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>.then() encadenado</td>
                        <td>Control detallado del flujo, útil para múltiples pasos</td>
                      </tr>
                      <tr>
                        <td>async/await</td>
                        <td>Sintaxis más limpia y parecida a código síncrono</td>
                      </tr>
                      <tr>
                        <td>try/catch en async</td>
                        <td>Permite manejo centralizado de errores</td>
                      </tr>
                    </tbody>
                  </table>
                  
               
            </div>
            </tema-item>
<!-- 13.DOM Avanzado -->
            <tema-item>
                <titulo>
                   <strong>13.Intermedio-DOM Avanzado.</strong><br>
                    <br>
                    <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
                <div>
                  <h2>DOM Avanzado.</h2>
                  <p><b>Crear y eliminar elementos</b></p>
                  <p><b>Crear elementos</b></p>
                <pre><code>
                    const nuevoElemento = document.createElement("p");
                    nuevoElemento.textContent = "Hola, soy un nuevo párrafo";
                    document.body.appendChild(nuevoElemento);
                </code></pre>
                <p><b>Eliminar elementos</b></p>
                <pre><code>
                    const eliminar = document.querySelector("p");
                    eliminar.remove(); // Elimina el elemento del DOM

                    <p>También se puede usar:</p>
                    padre.removeChild(hijo);
                </code></pre>
                <p><b>Manipulación de clases y estilos</b><br>Clases</p>
                <pre><code>
                    const elemento = document.querySelector(".mi-elemento");

                    elemento.classList.add("nueva-clase");     // Agrega clase
                    elemento.classList.remove("otra-clase");   // Elimina clase
                    elemento.classList.toggle("activa");       // Alterna clase
                    elemento.classList.contains("activa");     // Devuelve true/false

                    <p>Estilos</p>
                    elemento.style.color = "red";
                    elemento.style.backgroundColor = "#f0f0f0";
                <p>Puedes modificar cualquier propiedad CSS en camelCase.</p>    
                </code></pre>
                <p><b>Delegación de eventos</b><br>Es una técnica donde asignas el evento a un contenedor, en lugar de a cada hijo individual. Útil cuando los hijos se crean dinámicamente.</p>
                <pre><code>
                    <p.js</p>
                    document.getElementById("lista").addEventListener("click", (e) => {
                        if (e.target.tagName === "LI") {
                          alert(`Clic en: ${e.target.textContent}`);
                        }
                      });
                    <p>html</p>
                    <ul id="lista">
                        <li>Elemento 1</li>
                        <li>Elemento 2</li>
                      </ul>
                    <p>Ventaja: no necesitas volver a asignar eventos si agregas nuevos <li>.</p>                                           
                </code></pre>
                <p><b>Formularios y validación</b><br>Acceso a valores</p>
                <pre><code>
                    const formulario = document.querySelector("#mi-form");

                    formulario.addEventListener("submit", (e) => {
                    e.preventDefault(); // Evita recarga
                    const nombre = formulario.querySelector("input[name='nombre']").value;
                    console.log("Nombre:", nombre);
                 });

                </code></pre>
                <p><b>Validación básica</b></p>
                <pre><code>
                    formulario.addEventListener("submit", (e) => {
                        const nombre = formulario.nombre.value.trim();
                      
                        if (nombre === "") {
                          alert("El nombre es obligatorio");
                          e.preventDefault(); // Cancela el envío
                        }
                      });
                
                      <p>Puedes combinarlo con clases para mostrar errores visualmente:</p>

                      if (nombre === "") {
                        formulario.nombre.classList.add("error");
                      }
                    <p>También puedes usar validación HTML5 con required, minlength, etc., y complementarlo con JS para validaciones personalizadas.</p>    
             
                </code></pre>
                </div>
            </tema-item>
             
<!-- 14.Herramienta de desarrollo -->
            <tema-item>
                <titulo>
                    <strong>14.Intermedio-Herramientas de Desarrollo.</strong>
                    <br>
                    <strong></strong>
                </titulo>
                 <subtitulo></subtitulo>
                <div>
                 <h2>Herramientas de Desarrollo.</h2>
                  <p>Estas son funciones o extensiones que mejoran el flujo de trabajo del desarrollador:</p>
                  <p><b>Herramientas del navegador (DevTools)</b>Todos los navegadores modernos (Chrome, Firefox, Edge) incluyen:</p>
                  <p>·&nbsp;Consola (console.log, errores, advertencias).<br>
                     ·&nbsp;Inspector del DOM y estilos CSS.<br>
                     ·&nbsp;Debugger (puntos de interrupción, paso a paso).<br>
                     ·&nbsp;Network (ver llamadas fetch/AJAX).<br>
                     ·&nbsp;Performance (medir velocidad, FPS, etc.)<br>
                     <br>
                     Atajo: F12 o clic derecho → "Inspeccionar"
                    </p>
        
                  <p><b>Depuración en JavaScript</b><br>console.log(), console.error(), console.table(), console.dir()</p>
                  <code><pre>
                    console.log("Mensaje");            // Normal
                    console.error("Error");           // En rojo
                    console.table([{ a: 1 }, { a: 2 }]); // Tabla
                  </pre></code>
                  <p>Debugger:<br>Detiene la ejecución para inspeccionar variables:</p>
                  <code><pre>
                    function prueba() {
                        const x = 10;
                        debugger; // Pausa aquí si tienes DevTools abierto
                        const y = x * 2;
                        return y;
                      }                      
                  </pre></code>
                  <p><b>Linters - ESLint</b><br>Un linter analiza tu código para detectar errores, inconsistencias o malas prácticas.</p>
                 
                  <p><b>¿Qué es ESLint?</b><br>
                    ·&nbsp;Es el linter más usado en JS.<br>
                    ·&nbsp;Puedes definir reglas para estilos, errores comunes, buenas prácticas.<br>
                    ·&nbsp; Funciona con editores como VS Code.<br>
                   </p>
                  <code><pre>
                    npm install eslint --save-dev
                    npx eslint --init
                  </pre></code>
                  <p> Archivo .eslintrc.js ejemplo:</p>
                  <code><pre>
                    module.exports = {
                        env: {
                          browser: true,
                          es2021: true
                        },
                        extends: ['eslint:recommended'],
                        parserOptions: {
                          ecmaVersion: 12,
                          sourceType: 'module'
                        },
                        rules: {
                          'no-unused-vars': 'warn',
                          'semi': ['error', 'always']
                        }
                      };
                      
                  </pre></code>
                  <p><b>Introducción a NPM (Node Package Manager)</b></p>
                  <p><b>¿Qué es?</b><br>NPM es el gestor de paquetes de JavaScript. Sirve para:
                    ·&nbsp;Instalar librerías o frameworks (React, Vue, Express, etc.).<br>
                    ·&nbsp;Manejar dependencias del proyecto. <br>
                    ·&nbsp;Crear scripts para automatizar tareas. <br>
                    <br>
                    Comandos clave
                  </p>
                  <code><pre>
                    npm init          # Crea package.json
                    npm install       # Instala dependencias
                    npm install <paquete>       # Instala un paquete
                    npm install <paquete> --save-dev  # Solo para desarrollo
                    npm run (script)  # Corre un script definido en package.json
                  </pre></code>
                  <p>package.json ejemplo</p>
                  <code><pre>
                    {
                        "name": "mi-proyecto",
                        "version": "1.0.0",
                        "scripts": {
                          "lint": "eslint src/",
                          "start": "node index.js"
                        },
                        "dependencies": {
                          "axios": "^1.5.0"
                        },
                        "devDependencies": {
                          "eslint": "^8.56.0"
                        }
                      }
                  </pre></code>
                    <table border="2">
                        <thead>
                          <tr>
                            <th>Herramienta</th>
                            <th>Función Principal</th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr>
                            <td>DevTools</td>
                            <td>Inspección y depuración visual</td>
                          </tr>
                          <tr>
                            <td>console/debugger</td>
                            <td>Depurar y entender errores</td>
                          </tr>
                          <tr>
                            <td>ESLint</td>
                            <td>Linter para calidad de código</td>
                          </tr>
                          <tr>
                            <td>NPM</td>
                            <td>Manejo de paquetes y dependencias</td>
                          </tr>
                        </tbody>
                    </table>
                </div>
            </tema-item>
<!-- 15.Manejo Avanzado de Asincronía       -->
           <tema-item>
              <titulo>
                <strong>15.Manejo Avanzado de Asincronía</strong><br>
                 <br>
                <strong></strong>
                </titulo>
                <subtitulo></subtitulo>
              <div>
                <h2>Manejo Avanzado de Asincronía</h2>
                <p><b>fetch() API – Solicitudes HTTP</b><br>Permite hacer peticiones a servidores de forma sencilla y basada en promesas.</p>
             <code><pre>
                fetch("https://jsonplaceholder.typicode.com/posts/1")
                 .then((res) => res.json())
                 .then((data) => console.log(data))
                 .catch((error) => console.error("Error:", error));
             </pre></code>
             <p><b>AbortController – Cancelar solicitudes fetch<b><br>Controla la cancelación de peticiones fetch (útil para evitar fugas de memoria o peticiones innecesarias).</p>
             <code><pre>
                const controller = new AbortController();
                const signal = controller.signal;

                fetch("https://jsonplaceholder.typicode.com/posts", { signal })
                .then(res => res.json())
                .then(data => console.log("Datos:", data))
                .catch(err => {
                if (err.name === "AbortError") {
                console.warn("Solicitud abortada");
                } else {
                console.error("Error:", err);
                }
            });

            // Abortar luego de 100 ms
            setTimeout(() => controller.abort(), 100);
            </pre></code>   

             <p><b>Promesas paralelas</b><br>Promise.all() – Espera que todas se resuelvan</p>
             <code><pre>
                const promesa1 = fetch("https://jsonplaceholder.typicode.com/posts/1").then(r => r.json());
                const promesa2 = fetch("https://jsonplaceholder.typicode.com/users/1").then(r => r.json());

                Promise.all([promesa1, promesa2])
                .then(([post, user]) => {
                console.log("Post:", post);
                console.log("Usuario:", user);
              })
             .catch(err => console.error("Error en alguna promesa:", err));

             <p>Promise.race() – Se resuelve o rechaza con la primera promesa en completarse</p>

             const lenta = new Promise(resolve => setTimeout(() => resolve("Lenta"), 1000));
             const rapida = new Promise(resolve => setTimeout(() => resolve("Rápida"), 300));

             Promise.race([lenta, rapida]).then(resultado => {
             console.log("Ganó:", resultado); // "Rápida"
            });
             </pre></code>   
             <p><b>APIs Web útiles en el navegador</b>Temporizadores</p>
             <code><pre>
                setTimeout(() => console.log("Después de 1 segundo"), 1000);

                let count = 0;
                const intervalId = setInterval(() => {
                console.log("Contando:", ++count);
                if (count === 3) clearInterval(intervalId);
                }, 500);
             </pre></code>   
             <p>Geolocalización (si el navegador lo permite)</p>
             <code><pre>
                navigator.geolocation.getCurrentPosition(
                (pos) => {
                console.log("Lat:", pos.coords.latitude, "Long:", pos.coords.longitude);
                },
                (err) => {
                console.error("Error obteniendo ubicación:", err);
               }
              );
             </pre></code>   
             <p><b>Almacenamiento Web (localStorage y sessionStorage)</b></p>
             <code><pre>
                // localStorage (persiste aunque cierres el navegador)
                   localStorage.setItem("nombre", "Rodolfo");
                   console.log(localStorage.getItem("nombre")); // "Rodolfo"

                // sessionStorage (solo en la sesión actual)
                sessionStorage.setItem("tema", "oscuro");
             </pre></code>   
             <table border="1">
                <thead>
                  <tr>
                    <th>Herramienta / API</th>
                    <th>Uso Principal</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>fetch()</td>
                    <td>Hacer peticiones HTTP</td>
                  </tr>
                  <tr>
                    <td>AbortController</td>
                    <td>Cancelar peticiones en curso</td>
                  </tr>
                  <tr>
                    <td>Promise.all()</td>
                    <td>Ejecutar tareas en paralelo y esperar todas</td>
                  </tr>
                  <tr>
                    <td>Promise.race()</td>
                    <td>Obtener el resultado de la primera en resolverse</td>
                  </tr>
                  <tr>
                    <td>setTimeout, setInterval</td>
                    <td>Ejecutar tareas con retraso o repetición</td>
                  </tr>
                  <tr>
                    <td>geolocation</td>
                    <td>Obtener ubicación del usuario (con permiso)</td>
                  </tr>
                  <tr>
                    <td>localStorage, sessionStorage</td>
                    <td>Guardar datos localmente en el navegador</td>
                  </tr>
                </tbody>
              </table>
            </div>    
        </tema-item>
<!-- 16.Avanzado-Estructuras de Datos y Algoritmos en JavaScript. -->
        <tema-item>
         <titulo>
           <strong>16.Avanzado-Estructuras de Datos y Algoritmos en JavaScript.</strong><br>
             <br>
           <strong></strong>
         </titulo>
         <subtitulo></subtitulo>
         <div>
           <h2>Estructuras de Datos y Algoritmos en JavaScript.</h2>
            <p><b>1.Pilas (Stacks)</b><br>LIFO – Último en entrar, primero en salir.</p>
             <code><pre>
                class Stack {
                    constructor() {
                      this.items = [];
                    }
                    push(item) {
                      this.items.push(item);
                    }
                    pop() {
                      return this.items.pop();
                    }
                    peek() {
                      return this.items[this.items.length - 1];
                    }
                  }        
             </pre></code>   
             <p><b>2.Colas (Queues)</b><br>FIFO – Primero en entrar, primero en salir.</p>
             <code><pre>
                class Queue {
                    constructor() {
                      this.items = [];
                    }
                    enqueue(item) {
                      this.items.push(item);
                    }
                    dequeue() {
                      return this.items.shift();
                    }
                    front() {
                      return this.items[0];
                    }
                  }                  
             </pre></code>   
             <p><b>3.Listas enlazadas (Linked Lists)</b></p>
             <code><pre>
                class Node {
                    constructor(value) {
                      this.value = value;
                      this.next = null;
                    }
                  }
                  
                  class LinkedList {
                    constructor() {
                      this.head = null;
                    }
                  
                    append(value) {
                      const node = new Node(value);
                      if (!this.head) {
                        this.head = node;
                      } else {
                        let curr = this.head;
                        while (curr.next) {
                          curr = curr.next;
                        }
                        curr.next = node;
                      }
                    }
                  
                    print() {
                      let curr = this.head;
                      while (curr) {
                        console.log(curr.value);
                        curr = curr.next;
                      }
                    }
                  } 
             </pre></code>   
             <p><b>4.Árboles binarios (Binary Trees)</b></p>
             <code><pre>
                class TreeNode {
                    constructor(value) {
                      this.value = value;
                      this.left = null;
                      this.right = null;
                    }
                  }
                  
                  function inOrderTraversal(node) {
                    if (node) {
                      inOrderTraversal(node.left);
                      console.log(node.value);
                      inOrderTraversal(node.right);
                    }
                  }
                  
             </pre></code>   
             <p><b>5.Recursión</b><br>Una función que se llama a sí misma hasta cumplir una condición.<br>Ejemplo: factorial</p>
             <code><pre>
                function factorial(n) {
                    if (n === 0) return 1;
                    return n * factorial(n - 1);
                  }                  
             </pre></code>  
             <p>Ejemplo: Fibonacci</p>
             <code><pre>
                function fibonacci(n) {
                    if (n <= 1) return n;
                    return fibonacci(n - 1) + fibonacci(n - 2);
                  }
             </pre></code>  
             <p><b>6.Algoritmos comunes</b><br>Búsqueda lineal</p>
             <code><pre>
                function linearSearch(arr, target) {
                    for (let i = 0; i < arr.length; i++) {
                      if (arr[i] === target) return i;
                    }
                    return -1;
                  }                  
             </pre></code>  
             <p><b>Búsqueda binaria (requiere arreglo ordenado)</b></p>
             <code><pre>
                function binarySearch(arr, target) {
                    let left = 0, right = arr.length - 1;
                  
                    while (left <= right) {
                      let mid = Math.floor((left + right) / 2);
                  
                      if (arr[mid] === target) return mid;
                      else if (arr[mid] < target) left = mid + 1;
                      else right = mid - 1;
                    }
                  
                    return -1;
                  }                  
             </pre></code>  
             <p><b>Ordenamiento burbuja (Bubble Sort)</b></p>
             <code><pre>
                function bubbleSort(arr) {
                    let n = arr.length;
                    for (let i = 0; i < n; i++) {
                      for (let j = 0; j < n - i - 1; j++) {
                        if (arr[j] > arr[j + 1]) {
                          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // swap
                        }
                      }
                    }
                    return arr;
                  }                  
             </pre></code>  
             <p><b>Ordenamiento rápido (Quick Sort)</b></p>
             <code><pre>
                function quickSort(arr) {
                    if (arr.length <= 1) return arr;
                  
                    const pivot = arr[0];
                    const left = arr.slice(1).filter(x => x < pivot);
                    const right = arr.slice(1).filter(x => x >= pivot);
                  
                    return [...quickSort(left), pivot, ...quickSort(right)];
                  }
                  
             </pre></code>  
             <table border="1">
                <thead>
                  <tr>
                    <th>Tema</th>
                    <th>Ejemplo clave</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Pila (Stack)</td>
                    <td>push(), pop(), peek()</td>
                  </tr>
                  <tr>
                    <td>Cola (Queue)</td>
                    <td>enqueue(), dequeue()</td>
                  </tr>
                  <tr>
                    <td>Lista enlazada</td>
                    <td>append(), print()</td>
                  </tr>
                  <tr>
                    <td>Árbol binario</td>
                    <td>inOrderTraversal()</td>
                  </tr>
                  <tr>
                    <td>Recursión</td>
                    <td>factorial(n), fibonacci(n)</td>
                  </tr>
                  <tr>
                    <td>Búsqueda lineal</td>
                    <td>linearSearch(arr, target)</td>
                  </tr>
                  <tr>
                    <td>Búsqueda binaria</td>
                    <td>binarySearch(arr, target)</td>
                  </tr>
                  <tr>
                    <td>Ordenamiento burbuja</td>
                    <td>bubbleSort(arr)</td>
                  </tr>
                  <tr>
                    <td>Ordenamiento rápido</td>
                    <td>quickSort(arr)</td>
                  </tr>
                </tbody>
              </table>
              
            
         </div>
        </tema-item>
 <!-- 17.Avanzado-Javascript en el Navegador y API WEB.    -->
 <tema-item>
    <titulo>
        <strong>17.Avanzado-Javascript en el Navegador y API WEB.</strong><br>
        <br>
        <strong></strong>
    </titulo>
     <subtitulo></subtitulo>
    <div>
     <h2>Javascript en el Navegador y API WEB.</h2>
      <p>Sólo texto simple.</p>
      <p></p>
      <code><pre>
      </pre></code> 
      <p></p>
      <code><pre>
      </pre></code> 
      <p></p>
      <code><pre>
      </pre></code> 
    </div>
</tema-item>
<!-- 18.Avanzado-Patrones de Diseño en Javascript. -->
<tema-item>
    <titulo>
        <strong>18.Avanzado-Patrones de Diseño en Javascript.</strong><br>
        <br>
        <strong></strong>
    </titulo>
     <subtitulo></subtitulo>
    <div>
     <h2>Patrones de Diseño en Javascript.</h2>
      <p>Sólo texto simple.</p>
    </div>
</tema-item>
<!-- 19.Avanzado-Principios de Código Limpio y Buenas Prácticas -->
<tema-item>
    <titulo>
        <strong>19.Avanzado-Principios de Código Limpio y Buenas Prácticas </strong><br>
        <br>
        <strong></strong>
    </titulo>
     <subtitulo></subtitulo>
    <div>
     <h2>Principios de Código Limpio y Buenas Prácticas </h2>
      <p>Sólo texto simple.</p>
    </div>
</tema-item>
<!-- 20.Avanzado-Compiladores y Transpiladores -->
<tema-item>
    <titulo>
        <strong>20.Avanzado-Compiladores y Transpiladores</strong><br>
        <br>
        <strong></strong>
    </titulo>
     <subtitulo></subtitulo>
    <div>
     <h2>Compiladores y Transpiladores</h2>
      <p>Sólo texto simple.</p>
    </div>
</tema-item>

<!-- 21.Avanzado-Node.js e Integración Full-Stack. -->
<tema-item>
    <titulo>
        <strong>21.Avanzado-Node.js e Integración Full-Stack.</strong><br>
        <br>
        <strong></strong>
    </titulo>
     <subtitulo></subtitulo>
    <div>
     <h2>Node.js e Integración Full-Stack.</h2>
      <p>Sólo texto simple.</p>
    </div>
</tema-item>
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
        </mi-lista>





    </main>
    <footer class="footer">
        <mi-footer></mi-footer>
    </footer>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/nav.js" defer></script>
    <script src="js/footer.js" defer></script>
    <script src="js/lista.js" defer></script>
</body>

</html>